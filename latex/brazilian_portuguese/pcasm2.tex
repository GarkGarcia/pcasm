
\chapter{Linguagem de Assembly Básica}

\section{Trabalhando com Inteiros \index{integer|(}}

\subsection{Representação de Inteiros \index{integer!representation|(}}

\index{integer!unsigned|(}
Inteiros vêm em dois sabores: sem sinal e com sinal. Inteiros sem sinal (que 
são não negativos) são representados de uma maneira bem direta em binário.
O número 200 como um inteiro sem sinal de um byte seria representado por
11001000 (ou C8 em hex).
\index{integer!unsigned|)}

\index{integer!signed|(}
Inteiros com sinal (que podem ser positivo ou negativo) são representados de maneira
mais complicada. Por exemplo, considere $-56$. $+56$ como um byte seria
representado por 00111000. Na teoria, poderíamos representar $-56$ como $-111000$,
mas como isso seria representado em um byte na memória do computador?
Como o sinal negativo seria alocado?

Existem três técnicas gerais que vêm sendo usada para representar
inteiros com sinal na memória do computador. Todos estes métodos usam o bit
mais significativo do inteiro como um \emph{bit
de sinal}. \index{integer!sign bit} Este bit será 0 se o número for positivo
e 1 se for negativo.

\subsubsection{Sinal-e-magnitude \index{integer!representation!signed magnitude}}

O primeiro método é o mais simples e se chama \emph{sinal-e-magnitude} (ou sinal-magnitude). Ele 
representa o inteiro como duas partes. A primeira parte é o bit de sinal e 
a segunda parte é a magnitude do inteiro. Neste caso, 56 seria representado como
o byte $\underline{0}0111000$ (o bit de sinal está sublinhado) e $-56$
seria $\underline{1}0111000$. O maior valor de byte seria
$\underline{0}1111111$ ou $+127$ e o menor valor de byte seria 
$\underline{1}1111111$ ou $-127$. Para negar um valor, o bit de sinal é invertido.
Este método é direto, mas tem suas desvantagens. Primeiro,
há dois possíveis valores de zero, $+0$ ($\underline{0}0000000$) e
$-0$ ($\underline{1}0000000$). Como zero não é positivo nem negativo,
ambas representações devem agir da mesma forma. Isto complica a lógica 
da arimética da CPU. Segundo, aritmética geral é também complicada.
Se 10 é adicionado a $-56$, isso deve ser reformulado como 10 subtraído de 56. Novamente,
isso complica a lógica da CPU.

\subsubsection{Complemento para um \index{integer!representation!one's complement}}
O segundo método é conhecido como \emph{complemento para um}. O
complemento para um de algum número é encontrado ao inverter cada bit no número.
(Outra forma de compreender isso é que o novo valor de bit será $1 - \mathrm{antigo valor de bit}$.) 
Por exemplo, o complemento para um de 
$\underline{0}0111000$ ($+56$) é $\underline{1}1000111$. Na notação de complemento
para um, calcular o complemento para um é equivalente a negação. Assim,
$\underline{1}1000111$ é a representação para $-56$. Note que o bit de 
sinal foi alterado automaticamente pelo complemento para um e como é de se esperar 
tomar o complemento para um duas vezes produz o número original. Assim como no
primeiro método, existem duas representações de zero: 
$\underline{0}0000000$ ($+0$) e $\underline{1}1111111$ ($-0$). Artimética 
com o complemento para um é complicada.

Há um truque útil para encontrar o complemento para um de um número em
hexadecimal sem convertê-lo em binário. O truque é subtrair o dígito
hex do F (ou 15 in decimal). Este método assume que o número de
bits no número é um múltiplo de 4. Tome como exemplo: $+56$ é
representado por 38 em hex. Para encontrar seu complemento para um, subtraia cada
dígito de F para conseguir C7 em hex. Isso esta coerente com o resultado acima.

\subsubsection{Complemento para dois \index{integer!representation!two's complement|(}
               \index{two's complement|(}}

Os primeiros dois métodos descritos eram usados em computadores antigos. Computadores modernos
usam um terceiro método chamado \emph{complemento para dois}. O complemento
para dois de um número é encontrado a partir de dois passos:
\begin{enumerate}
\item Encontre o complemento para um do número em questão
\item Adicione um ao resultado encontrado no item anterior
\end{enumerate}
Veja um exemplo com $\underline{0}0111000$ (56). Primeiro calculamos o
complemento para um: $\underline{1}1000111$. Depois adicionamos um ao resultado:
\[
\begin{array}{rr}
 & \underline{1}1000111 \\
+&                    1 \\ \hline
 & \underline{1}1001000
\end{array}
\]

Na notação de complemento para dois, calcular o complemento para dois é equivalente
a negar um número. Portanto, $\underline{1}1001000$ é a representação do complemento
para dois de $-56$. Duas negações devem reproduzir o número original.
Surpreendentemente complemento para dois atende a este requisito. Tome o complemento
para dois de $\underline{1}1001000$ adicionando um ao complemento para um.
\[
\begin{array}{rr}
 & \underline{0}0110111 \\
+&                    1 \\ \hline
 & \underline{0}0111000
\end{array}
\]

Quando realizamos a adição numa operação de complemento para dois, a adição
do bit mais à esquerda pode produzir um carry. Este carry \emph{não} é usado. 
Lembre-se que todos os dados no computador são de algum tamanho fixo (em termos de 
números de bits). Adicionar dois bytes sempre produz um byte como resultado (assim
como unir duas palavras produz uma palavra, {\em etc\/}.) Esta propriedade é importante 
para a notação de complemento para dois. Por exemplo, considere zero como um número de
complemento para dois de um byte ($\underline{0}0000000$). Calcular seu complemento para dois
resulta na soma:
\[
\begin{array}{rr}
 & \underline{1}1111111 \\
+&                    1 \\ \hline
c& \underline{0}0000000
\end{array}
\]
em que $c$ representa um carry. (Posteriormente será mostrado como detectar este carry,
porém ele não é alocado no resultado.) Assim, na notação de complemento para dois existe
apenas um zero. Isto faz a aritmética de complemento para dois ser mais simples do que aquelas 
dos métodos anteriores.

\begin{table}
\centering
\begin{tabular}{||c|c||}
\hline
Número & Representação Hex \\
\hline
0 & 00 \\
1 & 01 \\
127 & 7F \\
-128 & 80 \\
-127 & 81 \\
-2 & FE \\
-1 & FF \\
\hline
\end{tabular}
\caption{Representação de Complemento para Dois \label{tab:twocomp}}
\end{table}

Usando a notação de complemento para dois, um byte com sinal pode ser usado para
representar os números de $-128$ a $+127$. A tabela~\ref{tab:twocomp} mostra alguns
valores selecionados. Se são usados 16 bits, os números com sinal de $-32,768$ a 
$+32,767$ podem ser representados. $+32,767$ é representado por 7FFF, 
$-32,768$ por 8000, -128 por FF80 e -1 por FFFF. Os números de 32 bit em complemento 
para dois no intervalo de $-2$ bilhões a $+2$ bilhões aproximadamente. 


A CPU tem ideia nenhuma idea do que um byte em particular (ou palavra ou palavra dupla) 
deveria representar. Assembly não possui a ideia de tipos que uma
linguagem de alto nível possui. A interpretação dos dados depende de qual instrução
é usada com o dado. Se o valor hex FF será considerado para representar
um número com sinal $-1$ ou um número sem sinal $+255$ dependerá da programadora. A linguagem C 
define tipos de inteiro com sinal e sem sinal. Isso permite um compilador de C a 
determinar a instrução correta a ser usada com o dado.

\index{two's complement|)}
\index{integer!representation!two's complement|)}
\index{integer!signed|)}

\subsection{Extensão de sinal \index{integer!sign extension|(}}

Em assembly, todo dado tem um tamanho específico. Não é incomum ter de precisar 
mudar o tamanho de um dado para usá-lo com outro dado. Reduzir o tamanho é o 
mais fácil.

\subsubsection{Reduzindo o tamanho de dados}

Para reduzir o tamanho do dado, basta remover os bits mais significativos do
dado. Veja um exemplo trivial:
\begin{AsmCodeListing}[numbers=none,frame=none]
      mov    ax, 0034h      ; ax = 52 (alocado 16 bits)
      mov    cl, al         ; cl = 8-bits a menos do que ax
\end{AsmCodeListing}

Claro, se o número não puder ser representado corretamente no tamanho
menor, reduzir o tamanho não irá funcionar. Por exemplo, se {\code AX}
for 0134h (ou 308 em decimal) então o código acima ainda armazenaria 
{\code CL} para 34h. Este método funciona tanto para números com sinal
quanto para números sem sinal. Considere números com sinal, se {\code AX} for FFFFh ($-1$ como uma
palavra), então {\code CL} seria FFh ($-1$ como um byte). Entretanto, note
que isto não é correto se o valor em {\code AX} for sem sinal!

A regra para números sem sinal é que todos os bits a serem removidos devem
ser 0 para a conversão ser correta. A regra para números com sinal é
que os bits a serem removidos devem ser ou todos 1 ou todos 0. Ademais,
o primeiro bit não removido deve ter o mesmo valor que os bits
removidos. Este bit será o novo bit de sinal do valor de tamanho menor.
É importante que seja igual ao bit de sinal do valor original!

\subsubsection{Aumentando o tamanho de dados}

Aumentar o tamanho do dado é mais complicado do que
reduzir. Considere o hex byte FF. Caso ele seja estendido para uma palavra,
qual valor a palavra deveria ter? Isso depende da forma como FF é
interpretada. Se FF é um byte sem sinal (255 em decimal), então a palavra
deverá ser 00FF; contudo, se for um byte com sinal ($-1$ em decimal),
então a palavra será FFFF.

Em geral, para estender um número sem sinal, faça todo os novos bits
do número expandido serem 0 (zeros). Deste modo, FF torna-se 00FF. Entretando, para estender um
número com sinal, deverá \emph{estender} o bit de sinal. 
\index{integer!sign bit} Isso quer dizer que os novos bits tornam-se
cópias do bit de sinal. Como o bit de sinal de FF é 1, os novos bits
também devem ser uns, para produzir FFFF. Caso extendêssemos o número com sinal 5A (90 in
decimal), o resultado seria 005A.

Existem várias instruções que o 80386 providencia para a estenção de
números. Lembre-se que o computador não sabe quando um número é com sinal
ou sem sinal. Vai da programadora utilizar a instrução correta.

Para números com sinal, pode-se simplesmente posicionar zeros nos bits superiores usando
a instrução {\code MOV}. Por exemplo, para estender o byte em AL para uma palavra 
sem sinal em AX:
\begin{AsmCodeListing}[numbers=none,frame=none]
      mov    ah, 0   ; zere 8-bits superiores
\end{AsmCodeListing}
Entretanto, não é possível utilizar a instrução {\code MOV} para
converter palavra sem sinal em AX em uma palavra dupla sem sinal em EAX. Por
que não? Bom, não há como especificar os 16 bits superiores de EAX em uma {\code
MOV}. O 80386 soluciona este problema providenciando uma nova instrução
{\code MOVZX}. \index{MOVZX} Esta instrução tem dois operandos. O destino
(primeiro operando) deve ser um registrador de 16 ou 32~bit.  A fonte (segundo
operando) pode ser um registrador de 8 ou 16~bit ou um byte ou palavra de 
memória. A outra restrição é que o destino deve ser maior do que
a fonte. (Maioria das instruções requer que a fonte e o destino tenham
o mesmo tamanho.) Aqui vão alguns exemplos:
\begin{AsmCodeListing}[numbers=none,frame=none]
      movzx  eax, ax      ; estende ax em eax
      movzx  eax, al      ; estende al em eax
      movzx  ax, al       ; estende al em ax
      movzx  ebx, ax      ; estende ax em ebx
\end{AsmCodeListing}

Para números com sinal, não há maneira fácil de utilizar a instrução {\code MOV}. 
O 8086 providencias diversas instruções para estender
números com sinal.  A instrução {\code CBW} \index{CBW} (Convert Byte to
Word) estende o registrador AL em AX. Os operandos
estão implícitos. A instrução {\code CWD} \index{CWD} (Convert Word to Double
word) estende AX em DX:AX. A notação DX:AX significa
enxergar os registradores DX e AX como um registrador de 32~bit com os
 16 bits superiores em DX e os bits inferiores em AX. (Lembre-se que o 8086
não possui nenhum registrador de 32~bit!) O 80386 adicionou várias novas
instruções. A instrução {\code CWDE} \index{CWDE} (Convert Word to Double
word Extended) estende AX em EAX. A instrução {\code CDQ}
\index{CDQ} (Convert Double word to Quad word) 
estende EAX em EDX:EAX\index{register!EDX:EAX} (64~bits!). Finalmente, a
instrução {\code MOVSX} \index{MOVSX} funciona similar a {\code MOVZX}
exceto pelo fato de usar as regras para números com sinal.

\subsubsection{Aplicação para programação em C}

Estender \MarginNote{ANSI C não define se o tipo {\code char}
é com sinal ou não, vai de cada compilador decidir
isto. Este é o motivo do tipo ser explicitamente definido em
Figure~\ref{fig:charExt}.} inteiros com e sem sinal também ocorrem
em C. Variáveis em C podem ser declaradas como como sinal ou sem sinal
({\code int} é com sinal). Considere o código em 
Figure~\ref{fig:charExt}.  Na linha~3, a variável {\code a} é
estendida por meio das regras para valores sem sinal (usando {\code MOVZX}), mas na 
linha~4, as regras para valores com sinal é utilizada em {\code b} (usando {\code MOVSX}).

\begin{figure}[t]
\begin{lstlisting}[frame=tlrb]{}
unsigned char uchar = 0xFF;
signed char   schar = 0xFF;
int a = (int) uchar;     /* a = 255 (0x000000FF) */
int b = (int) schar;     /* b = -1  (0xFFFFFFFF) */
\end{lstlisting}
\caption{}
\label{fig:charExt}
\end{figure}

Há um erro comum na programação em C diretamente relacionado com este assunto.
Considere o código em Figure~\ref{fig:IObug}. O protótipo de 
{\code fgetc()}{\samepage é:
\begin{CodeQuote}
int fgetc( FILE * );
\end{CodeQuote}
Alguém poderia se perguntar }Por que a função retorna um {\code int}
sendo que lê caracteres? A razão é que normalmenta ela retorna
um {\code char} (estendido em um valor {\code int} utilizando a extenção
zero). Contudo, existe um valor possível de ser retornado que não é
um caractere, {\code EOF}. Este é um macro usualmente definido como 
$-1$. Portando, {\code fgetc()} retorna ou um {\code char}
estendido em um {\code int} (que é como {\code 000000{\em
xx}} em hex) ou {\code EOF} (que é como {\code FFFFFFFF} em
hex).

\begin{figure}[t]
\begin{lstlisting}[stepnumber=0,frame=tlrb]{}
char ch;
while( (ch = fgetc(fp)) != EOF ) {
  /* do something with ch */
}
\end{lstlisting}
\caption{}
\label{fig:IObug}
\end{figure}

O principal problema com o programa em Figure~\ref{fig:IObug} é que
{\code fgetc()} retorna um {\code int}, mas este valor é alocado em um
{\code char}. C irá truncar os bits de ordem superior para se adequar o valor {\code
int} no {\code char}. O único problema é que ambos os números
(em hex) {\code 000000FF} e {\code FFFFFFFF} serão truncados
para o byte {\code FF}. Desta forma, o ciclo while não pode ser distinguido 
entre o byte {\code FF} do arquivo e o fim do arquivo.

O que exatamente o código faz neste caso, depende de o {\code char} ser
com ou sem sinal. Por quê? Porque na linha~2, {\code ch} é comparado com 
{\code EOF}. Dado que {\code EOF} é um valor {\code int}\footnote{É um
conceito errôneo comum pensar que arquivos possuem um caractere EOF em seu final. Isto
\emph{não} é verdade!}, {\code ch} será
estendido em um {\code int} de forma que os dois valores comparados são do 
mesmo tamanho\footnote{O motivo desse requerimento será demonstrado posteriormente.}.
Como mostrado por Figure~\ref{fig:charExt}, a variável ser com ou sem sinal 
é bastante importante.

Caso {\code char} seja sem sinal, {\code FF} é estendido para {\code
000000FF}. Isto é comparado com {\code EOF} ({\code FFFFFFFF}) e
resulta em não ser igual. Assim, o ciclo nunca acaba!

Caso {\code char} é com sinal, {\code FF} é estendido para {\code
FFFFFFFF}. Isto é comparado como igual e o ciclo tem fim. Contudo,
como o byte {\code FF} pode ter sido lido do arquivo, o ciclo 
pode ter terminado prematuramente.

A solução para este problema é definir a variável {\code ch} como um
{\code int}, não como um {\code char}. Quando isto é feito, não há truncamento ou
extenção na linha~2. Dentro do ciclo, é seguro truncar o
valor já que {\code ch} \emph{deve} de fato ser um simples byte ali.

\index{integer!sign extension|)}
\index{integer!representation|)}

\subsection{Aritmética de complemento para dois \index{two's complement!arithmetic|(}}

Como visto anteriormente, a instrução {\code add} efetua adição e
a instrução {\code sub} efetua a subtração. Dois dos bits nos
registradores FLAGS que são alterados por estas instruções são as bandeiras \emph{overflow}
e \emph{carry}. A bandeira overflow é alterada caso o resultado verdadeiro da
operação for grande demais para caber no destino reservado para artimética 
com sinal. A bandeira carry é alterada se há um carry no bit mais significativo da
adição ou um empréstimo no bit mais significativo da subtração. Deste modo, pode se usar
para detectar overflow para aritmética sem sinal. O uso da bandeira carry 
para aritmética com sinal será bisto brevemente. Uma das grandes vantagens
do complemento para dois é que as regras para adição e 
para subtração são exatamente as mesmas para os inteiros sem sinal. Assim,
{\code add} e {\code sub} podem ser utilizados em inteiro com ou sem 
sinal.
\[
\begin{array}{rrcrr}
 & 002\mathrm{C} & & & 44\\
+& \mathrm{FFFF} & &+&(-1)\\ \cline{1-2} \cline{4-5}
 & 002\mathrm{B} & & & 43
\end{array}
\]
Há um carry gerado, mas não faz parte da resposta.

\index{integer!multiplication|(}
\index{MUL|(}
\index{IMUL|(}
Existem duas instruções diferentes para multiplicação e para divisão. Primeiro, para
multiplicar utiliza-se a instrução {\code MUL} ou {\code IMUL}. A
instrução {\code MUL} é usada para multiplicar números sem sinal e
{\code IMUL} é utilizada para multiplicar inteiros com sinal. Por que são
necessárias duas instruções diferentes? As regras para multiplicação são
diferentes para números sem sinal e números complemento para dois com sinal. Como?
Considere a multiplicação do byte FF por ele mesmo produzindo uma palavra
como resultado. Utilizando a multiplicação sem sinal isto é 255 vezes 255 ou 65025
(ou FE01 em hex). Utilizando a multiplicação com sinal isto é $-1$ vezes $-1$ ou
1 (ou 0001 em hex).

Há várias maneiras das instruções de multiplicação. A maneira mais 
antiga é como:
\begin{AsmCodeListing}[numbers=none,frame=none]
      mul   source
\end{AsmCodeListing}
A \emph{fonte} é ou um registrador ou uma referência de memória. A fonte não pode ser  
um valor imediato. Qual multiplicação exatamente é efetuada depende do
tamanho do operando da fonte. Se o operando é do tamanho de byte, este é multiplicado pelo
byte no registrador AL e o resultado é alocado em 16 bits de AX.
Caso a fonte seja 16-bit, este é multiplicado pela palavra em AX e o resultado de 32-bit
é alocado em DX:AX. Se a fonte é 32-bit, este é multiplicado por EAX
e o resultado de 64-bit é alocado em EDX:EAX\index{register!EDX:EAX}.
\index{MUL|)}

\begin{table}[t]
\centering
\begin{tabular}{|c|c|c|l|}
\hline
{ \bf dest} & { \bf source1 } & {\bf source2} & \multicolumn{1}{c|}{\bf Action} \\ \hline
            & reg/mem8        &               & AX = AL*source1 \\
            & reg/mem16       &               & DX:AX = AX*source1 \\
            & reg/mem32       &               & EDX:EAX = EAX*source1 \\
reg16       & reg/mem16       &               & dest *= source1 \\
reg32       & reg/mem32       &               & dest *= source1 \\
reg16       & immed8          &               & dest *= immed8 \\
reg32       & immed8          &               & dest *= immed8 \\
reg16       & immed16         &               & dest *= immed16 \\
reg32       & immed32         &               & dest *= immed32 \\
reg16       & reg/mem16       & immed8        & dest = source1*source2 \\
reg32       & reg/mem32       & immed8        & dest = source1*source2 \\
reg16       & reg/mem16       & immed16       & dest = source1*source2 \\
reg32       & reg/mem32       & immed32       & dest = source1*source2 \\
\hline
\end{tabular}
\caption{{\code imul} Instructions \label{tab:imul}}
\end{table}

A instrução {\code IMUL} possui o mesmo formato que {\code MUL}, porém também 
adiciona alguns outros formatos de instrução. Existem formatos de dois e três operandos:
\begin{AsmCodeListing}[numbers=none,frame=none]
      imul   dest, source1
      imul   dest, source1, source2
\end{AsmCodeListing}
Table~\ref{tab:imul} mostra as possíveis combinações.
\index{IMUL|)}
\index{integer!multiplication|)}

\index{integer!division|(}
\index{DIV}
Os dois operadores da divisão são {\code DIV} e {\code IDIV}. Eles efetuam a
divisão de inteiros com e sem sinal, respectivamente. O formato geral é:
\begin{AsmCodeListing}[numbers=none,frame=none]
      div   source
\end{AsmCodeListing}
If the source is 8-bit, then AX is divided by the operand. The
quotient is stored in AL and the remainder in AH. If the source is
16-bit, then DX:AX is divided by the operand. The quotient is stored
into AX and remainder into DX. If the source is 32-bit, then
EDX:EAX\index{register!EDX:EAX} is divided by the operand and the quotient is
stored into EAX and the remainder into EDX. The {\code IDIV}
\index{IDIV} instruction works the same way. There are no special
{\code IDIV} instructions like the special {\code IMUL} ones. If the
quotient is too big to fit into its register or the divisor is zero,
the program is interrupted and terminates. A very common error is to
forget to initialize DX or EDX before division.
\index{integer!division|)}

The {\code NEG} \index{NEG} instruction negates its single operand by computing
its two's complement. Its operand may be any 8-bit, 16-bit, or 32-bit
register or memory location.

\subsection{Example program}
\index{math.asm|(}
\begin{AsmCodeListing}[label=math.asm]
%include "asm_io.inc"
segment .data         ; Output strings
prompt          db    "Enter a number: ", 0
square_msg      db    "Square of input is ", 0
cube_msg        db    "Cube of input is ", 0
cube25_msg      db    "Cube of input times 25 is ", 0
quot_msg        db    "Quotient of cube/100 is ", 0
rem_msg         db    "Remainder of cube/100 is ", 0
neg_msg         db    "The negation of the remainder is ", 0

segment .bss
input   resd 1

segment .text
        global  _asm_main
_asm_main:
        enter   0,0               ; setup routine
	pusha

        mov     eax, prompt
        call    print_string

        call    read_int
        mov     [input], eax

        imul    eax               ; edx:eax = eax * eax
        mov     ebx, eax          ; save answer in ebx
        mov     eax, square_msg
        call    print_string
        mov     eax, ebx
        call    print_int
        call    print_nl

        mov     ebx, eax
        imul    ebx, [input]      ; ebx *= [input]
        mov     eax, cube_msg
        call    print_string
        mov     eax, ebx
        call    print_int
        call    print_nl

        imul    ecx, ebx, 25      ; ecx = ebx*25
        mov     eax, cube25_msg
        call    print_string
        mov     eax, ecx
        call    print_int
        call    print_nl

        mov     eax, ebx
        cdq                       ; initialize edx by sign extension
        mov     ecx, 100          ; can't divide by immediate value
        idiv    ecx               ; edx:eax / ecx
        mov     ecx, eax          ; save quotient into ecx
        mov     eax, quot_msg
        call    print_string
        mov     eax, ecx
        call    print_int
        call    print_nl
        mov     eax, rem_msg
        call    print_string
        mov     eax, edx
        call    print_int
        call    print_nl
        
        neg     edx               ; negate the remainder
        mov     eax, neg_msg
        call    print_string
        mov     eax, edx
        call    print_int
        call    print_nl

        popa
        mov     eax, 0            ; return back to C
        leave                     
        ret
\end{AsmCodeListing}
\index{math.asm|)}

\subsection{Extended precision arithmetic \label{sec:ExtPrecArith} \index{integer!extended precision|(}}}

Assembly language also provides instructions that allow one to perform
addition and subtraction of numbers larger than double words. These
instructions use the carry flag. As stated above, both the {\code ADD}
\index{ADD} and {\code SUB} \index{SUB} instructions modify the carry
flag if a carry or borrow are generated, respectively. This
information stored in the carry flag can be used to add or subtract
large numbers by breaking up the operation into smaller double word
(or smaller) pieces.

The {\code ADC} \index{ADC} and {\code SBB} \index{SBB} instructions
use this information in the carry flag. The {\code ADC} instruction
performs the following operation:
\begin{center}
{\code \emph{operand1} = \emph{operand1} + carry flag + \emph{operand2} }
\end{center}
The {\code SBB} instruction performs:
\begin{center}
{\code \emph{operand1} = \emph{operand1} - carry flag - \emph{operand2} }
\end{center}
How are these used? Consider the sum of 64-bit integers in
EDX:EAX\index{register!EDX:EAX} and EBX:ECX. The following code would store the
sum in EDX:EAX:
\begin{AsmCodeListing}[frame=none]
      add    eax, ecx       ; add lower 32-bits
      adc    edx, ebx       ; add upper 32-bits and carry from previous sum
\end{AsmCodeListing}
Subtraction is very similar. The following code subtracts EBX:ECX from 
EDX:EAX:
\begin{AsmCodeListing}[frame=none]
      sub    eax, ecx       ; subtract lower 32-bits
      sbb    edx, ebx       ; subtract upper 32-bits and borrow
\end{AsmCodeListing}

For \emph{really} large numbers, a loop could be used (see 
Section~\ref{sec:control}). For a sum loop, it would be convenient to use
{\code ADC} instruction for every iteration (instead of all but the first
iteration). This can be done by using the {\code CLC} \index{CLC} (CLear Carry)
instruction right before the loop starts to initialize the carry flag to 0.
If the carry flag is 0, there is no difference between the {\code ADD} and
{\code ADC} instructions. The same idea can be used for subtraction, too.
\index{integer!extended precision|)}
\index{two's complement!arithmetic|)}

\section{Control Structures}
\label{sec:control}
High level languages provide high level control structures (\emph{e.g.}, the
\emph{if} and \emph{while} statements) that control the thread of execution.
Assembly language does not provide such complex control structures. It instead
uses the infamous \emph{goto} and used inappropriately can result in
spaghetti code! However, it \emph{is} possible to write structured assembly
language programs. The basic procedure is to design the program logic using
the familiar high level control structures and translate the design into
the appropriate assembly language (much like a compiler would do).

\subsection{Comparisons \index{integer!comparisons|(} \index{CMP|(}}
%TODO: Make a table of all the FLAG bits

\index{register!FLAGS|(}
Control structures decide what to do based on comparisons of data. In
assembly, the result of a comparison is stored in the FLAGS register
to be used later. The 80x86 provides the {\code CMP} instruction to
perform comparisons.  The FLAGS register is set based on the
difference of the two operands of the {\code CMP} instruction. The
operands are subtracted and the FLAGS are set based on the result, but
the result is \emph{not} stored anywhere. If you need the result use
the SUB instead of the {\code CMP} instruction.

\index{integer!unsigned|(}
For unsigned integers, there are two flags (bits in the FLAGS
register) that are important: the zero (ZF) \index{register!FLAGS!ZF} and carry (CF) 
\index{register!FLAGS!CF} flags. The
zero flag is set (1) if the resulting difference would be zero. The
carry flag is used as a borrow flag for subtraction. Consider a
comparison like:
\begin{AsmCodeListing}[frame=none, numbers=none]
      cmp    vleft, vright
\end{AsmCodeListing}
The difference of {\code vleft~-~vright} is computed and the flags are
set accordingly. If the difference of the of {\code CMP} is zero, {\code 
vleft~=~vright}, then ZF is set (\emph{i.e.} 1) and the CF is unset
(\emph{i.e.} 0). If {\code vleft~>~vright}, then ZF is unset and CF
is unset (no borrow). If {\code vleft~<~vright}, then ZF is unset and
CF is set (borrow).
\index{integer!unsigned|)}

\index{integer!signed|(} 
For signed integers, there are three flags
that are important: the zero \index{register!FLAGS!ZF} (ZF) flag, the
overflow \index{register!FLAGS!OF}(OF) flag and the sign
\index{register!FLAGS!SF} (SF) flag. \MarginNote{Why does SF~=~OF if
{\code vleft~>~vright}? If there is no overflow, then the difference
will have the correct value and must be non-negative. Thus,
SF~=~OF~=~0. However, if there is an overflow, the difference will not
have the correct value (and in fact will be negative). Thus,
SF~=~OF~=~1.}The overflow flag is set if the result of an operation
overflows (or underflows). The sign flag is set if the result of an
operation is negative. If {\code vleft~=~vright}, the ZF is set (just
as for unsigned integers). If {\code vleft~>~vright}, ZF is unset and
SF~=~OF.  If {\code vleft~<~vright}, ZF is unset and SF~$\neq$~OF.
\index{integer!signed|)}

Do not forget that other instructions can also change the FLAGS
register, not just {\code CMP}.
\index{CMP|)}
\index{integer!comparisons|)}
\index{register!FLAGS|)}
\index{integer|)}

\subsection{Branch instructions}

Branch instructions can transfer execution to arbitrary points of a program.
In other words, they act like a \emph{goto}. There are two types of branches:
unconditional and conditional. An unconditional branch is just like a goto,
it always makes the branch. A conditional branch may or may not make the
branch depending on the flags in the FLAGS register. If a conditional branch
does not make the branch, control passes to the next instruction.

\index{JMP|(}
The {\code JMP} (short for \emph{jump}) instruction makes
unconditional branches. Its single argument is usually a \emph{code
label} to the instruction to branch to. The assembler or linker will
replace the label with correct address of the instruction. This is
another one of the tedious operations that the assembler does to make
the programmer's life easier. It is important to realize that the
statement immediately after the {\code JMP} instruction will never be
executed unless another instruction branches to it!

There are several variations of the jump instruction:
\begin{description}

\item[SHORT] This jump is very limited in range. It can only move up or
down 128 bytes in memory. The advantage of this type is that it uses less
memory than the others. It uses a single signed byte to store the 
\emph{displacement} of the jump. The displacement is how many bytes to move 
ahead or behind. (The displacement is added to EIP). To specify a
short jump, use the {\code SHORT} keyword immediately before the label
in the {\code JMP} instruction.

\item[NEAR] This jump is the default type for both unconditional and 
conditional branches, it can be used to jump to any location in a
segment. Actually, the 80386 supports two types of near jumps.  One
uses two bytes for the displacement. This allows one to move up or
down roughly 32,000 bytes. The other type uses four bytes for the
displacement, which of course allows one to move to any location in
the code segment. The four byte type is the default in 386 protected
mode. The two byte type can be specified by putting the {\code WORD}
keyword before the label in the {\code JMP} instruction.

\item[FAR] This jump allows control to move to another code segment. This is
a very rare thing to do in 386 protected mode.
\end{description}

Valid code labels follow the same rules as data labels. Code labels
are defined by placing them in the code segment in front of the statement
they label. A colon is placed at the end of the label at its point of
definition. The colon is \emph{not} part of the name.
\index{JMP|)}

\index{conditional branch|(}
\begin{table}[t]
\center
\begin{tabular}{|ll|}
\hline
JZ  & branches only if ZF is set \\
JNZ & branches only if ZF is unset \\
JO  & branches only if OF is set \\
JNO & branches only if OF is unset \\
JS  & branches only if SF is set \\
JNS & branches only if SF is unset \\
JC  & branches only if CF is set \\
JNC & branches only if CF is unset \\
JP  & branches only if PF is set \\
JNP & branches only if PF is unset \\
\hline
\end{tabular}
\caption{Simple Conditional Branches \label{tab:SimpBran} \index{JZ} \index{JNZ}
        \index{JO} \index{JNO} \index{JS} \index{JNS} \index{JC} \index{JNC}
        \index{JP} \index{JNP}}
\end{table}

There are many different conditional branch instructions. They also
take a code label as their single operand. The simplest ones just look
at a single flag in the FLAGS register to determine whether to branch
or not.  See Table~\ref{tab:SimpBran} for a list of these
instructions. (PF is the \emph{parity flag} \index{register!FLAGS!PF}
which indicates the odd or evenness of the number of bits set in the
lower 8-bits of the result.)

The following pseudo-code:
\begin{Verbatim}
if ( EAX == 0 )
  EBX = 1;
else
  EBX = 2;
\end{Verbatim}
could be written in assembly as:
\begin{AsmCodeListing}[frame=none]
      cmp    eax, 0            ; set flags (ZF set if eax - 0 = 0)
      jz     thenblock         ; if ZF is set branch to thenblock
      mov    ebx, 2            ; ELSE part of IF
      jmp    next              ; jump over THEN part of IF
thenblock:
      mov    ebx, 1            ; THEN part of IF
next:
\end{AsmCodeListing}

Other comparisons are not so easy using the conditional branches in 
Table~\ref{tab:SimpBran}. To illustrate, consider the following pseudo-code:
\begin{Verbatim}
if ( EAX >= 5 )
  EBX = 1;
else
  EBX = 2;
\end{Verbatim}
If EAX is greater than or equal to five, the ZF may be set or unset and SF
will equal OF. Here is assembly code that tests for these conditions 
(assuming that EAX is signed):
\begin{AsmCodeListing}[frame=none]
      cmp    eax, 5
      js     signon            ; goto signon if SF = 1
      jo     elseblock         ; goto elseblock if OF = 1 and SF = 0
      jmp    thenblock         ; goto thenblock if SF = 0 and OF = 0
signon:
      jo     thenblock         ; goto thenblock if SF = 1 and OF = 1
elseblock:
      mov    ebx, 2
      jmp    next
thenblock:
      mov    ebx, 1
next:
\end{AsmCodeListing}

\begin{table}
\center
\begin{tabular}{|ll|ll|}
\hline
\multicolumn{2}{|c|}{\textbf{Signed}} & \multicolumn{2}{c|}{\textbf{Unsigned}} \\
\hline
JE & branches if {\code vleft = vright} & JE & branches if {\code vleft = vright} \\
JNE & branches if {\code vleft $\neq$ vright} & JNE & branches if {\code vleft $\neq$ vright} \\
JL, JNGE & branches if {\code vleft < vright} & JB, JNAE & branches if {\code vleft < vright} \\
JLE, JNG & branches if {\code vleft $\leq$ vright} & JBE, JNA & branches if {\code vleft $\leq$ vright} \\
JG, JNLE & branches if {\code vleft > vright} & JA, JNBE & branches if {\code vleft > vright} \\
JGE, JNL & branches if {\code vleft $\geq$ vright} & JAE, JNB & branches if {\code vleft $\geq$ vright} \\
\hline
\end{tabular}
\caption{Signed and Unsigned Comparison Instructions \label{tab:CompBran} \index{JE} \index{JNE}
         \index{JL} \index{JNGE} \index{JLE} \index{JNG} \index{JG} \index{JNLE} \index{JGE}
         \index{JNL}}
\end{table}

The above code is very awkward. Fortunately, the 80x86 provides additional
branch instructions to make these type of tests \emph{much} easier. There
are signed and unsigned versions of each. Table~\ref{tab:CompBran} shows
these instructions. The equal and not equal branches (JE and JNE) are the
same for both signed and unsigned integers. (In fact, JE and JNE are really
identical to JZ and JNZ, respectively.) Each of the other branch 
instructions have two synonyms. For example, look at JL (jump less than) and
JNGE (jump not greater than or equal to). These are the same instruction
because:
\[ x < y \Longrightarrow \mathbf{not}( x \geq y ) \]
The unsigned branches use A for \emph{above} and B for \emph{below} instead of
L and G.

Using these new branch instructions, the pseudo-code above can be translated
to assembly much easier.
\begin{AsmCodeListing}[frame=none]
      cmp    eax, 5
      jge    thenblock
      mov    ebx, 2
      jmp    next
thenblock:
      mov    ebx, 1
next:
\end{AsmCodeListing}
\index{conditional branch|)}

\subsection{The loop instructions}

The 80x86 provides several instructions designed to implement 
\emph{for}-like loops. Each of these instructions takes a code label
as its single operand.
\begin{description}
\item[LOOP] 
\index{LOOP}
Decrements ECX, if ECX $\neq$ 0, branches to label
\item[LOOPE, LOOPZ]
\index{LOOPE} \index{LOOPZ}
Decrements ECX (FLAGS register is not modified), if
                    ECX $\neq$ 0 and ZF = 1, branches
\item[LOOPNE, LOOPNZ]
\index{LOOPNE} \index{LOOPNZ}
Decrements ECX (FLAGS unchanged), if ECX $\neq$ 0
                      and ZF = 0, branches
\end{description}

The last two loop instructions are useful for sequential search loops. The
following pseudo-code:
\begin{lstlisting}[stepnumber=0]{}
sum = 0;
for( i=10; i >0; i-- )
  sum += i;
\end{lstlisting}
\noindent could be translated into assembly as:
\begin{AsmCodeListing}[frame=none]
      mov    eax, 0          ; eax is sum
      mov    ecx, 10         ; ecx is i
loop_start:
      add    eax, ecx
      loop   loop_start
\end{AsmCodeListing}

\section{Translating Standard Control Structures}

This section looks at how the standard control structures of high level
languages can be implemented in assembly language.

\subsection{If statements \index{if statment|(}}
The following pseudo-code:
\begin{lstlisting}[stepnumber=0]{}
if ( condition )
  then_block;
else
  else_block;
\end{lstlisting}
\noindent could be implemented as:
\begin{AsmCodeListing}[frame=none]
      ; code to set FLAGS
      jxx    else_block    ; select xx so that branches if condition false
      ; code for then block
      jmp    endif
else_block:
      ; code for else block
endif:
\end{AsmCodeListing}

If there is no else, then the {\code else\_block} branch can be replaced by
a branch to {\code endif}.
\begin{AsmCodeListing}[frame=none]
      ; code to set FLAGS
      jxx    endif          ; select xx so that branches if condition false
      ; code for then block
endif:
\end{AsmCodeListing}
\index{if statment|)}

\subsection{While loops \index{while loop|(}}
The \emph{while} loop is a top tested loop:
\begin{lstlisting}[stepnumber=0]{}
while( condition ) {
  body of loop;
}
\end{lstlisting}
\noindent This could be translated into:
\begin{AsmCodeListing}[frame=none]
while:
      ; code to set FLAGS based on condition
      jxx    endwhile       ; select xx so that branches if false
      ; body of loop
      jmp    while
endwhile:
\end{AsmCodeListing}
\index{while loop|)}

\subsection{Do while loops \index{do while loop|(}}
The \emph{do while} loop is a bottom tested loop:
\begin{lstlisting}[stepnumber=0]{}
do {
  body of loop;
} while( condition );
\end{lstlisting}
\noindent This could be translated into:
\begin{AsmCodeListing}[frame=none]
do:
      ; body of loop
      ; code to set FLAGS based on condition
      jxx    do          ; select xx so that branches if true
\end{AsmCodeListing}
\index{do while loop|)}


\begin{figure}[t]
\begin{lstlisting}[frame=tlrb]{}
  unsigned guess;   /* current guess for prime      */
  unsigned factor;  /* possible factor of guess     */
  unsigned limit;   /* find primes up to this value */

  printf("Find primes up to: ");
  scanf("%u", &limit);
  printf("2\n");    /* treat first two primes as  */
  printf("3\n");    /* special case               */
  guess = 5;        /* initial guess */
  while ( guess <= limit ) {
    /* look for a factor of guess */
    factor = 3;
    while ( factor*factor < guess &&
            guess % factor != 0 )
     factor += 2;
    if ( guess % factor != 0 )
      printf("%d\n", guess);
    guess += 2;    /* only look at odd numbers */
  }
\end{lstlisting}
\caption{}\label{fig:primec}
\end{figure}

\section{Example: Finding Prime Numbers}
This section looks at a program that finds prime numbers. Recall that
prime numbers are evenly divisible by only 1 and themselves. There is
no formula for doing this. The basic method this program uses is to
find the factors of all odd numbers\footnote{2 is the only even prime
number.} below a given limit. If no factor can be found for an odd
number, it is prime.  Figure~\ref{fig:primec} shows the basic
algorithm written in C.

Here's the assembly version:
\index{prime.asm|(}
\begin{AsmCodeListing}[label=prime.asm]
%include "asm_io.inc"
segment .data
Message         db      "Find primes up to: ", 0

segment .bss
Limit           resd    1               ; find primes up to this limit
Guess           resd    1               ; the current guess for prime

segment .text
        global  _asm_main
_asm_main:
        enter   0,0               ; setup routine
        pusha

        mov     eax, Message
        call    print_string
        call    read_int             ; scanf("%u", & limit );
        mov     [Limit], eax

        mov     eax, 2               ; printf("2\n");
        call    print_int
        call    print_nl
        mov     eax, 3               ; printf("3\n");
        call    print_int
        call    print_nl

        mov     dword [Guess], 5     ; Guess = 5;
while_limit:                         ; while ( Guess <= Limit )
        mov     eax,[Guess]
        cmp     eax, [Limit]
        jnbe    end_while_limit      ; use jnbe since numbers are unsigned

        mov     ebx, 3               ; ebx is factor = 3;
while_factor:
        mov     eax,ebx
        mul     eax                  ; edx:eax = eax*eax
        jo      end_while_factor     ; if answer won't fit in eax alone
        cmp     eax, [Guess]
        jnb     end_while_factor     ; if !(factor*factor < guess)
        mov     eax,[Guess]
        mov     edx,0
        div     ebx                  ; edx = edx:eax % ebx
        cmp     edx, 0
        je      end_while_factor     ; if !(guess % factor != 0)

        add     ebx,2                ; factor += 2;
        jmp     while_factor
end_while_factor:
        je      end_if               ; if !(guess % factor != 0)
        mov     eax,[Guess]          ; printf("%u\n")
        call    print_int
        call    print_nl
end_if:
        add     dword [Guess], 2     ; guess += 2
        jmp     while_limit
end_while_limit:

        popa
        mov     eax, 0            ; return back to C
        leave                     
        ret
\end{AsmCodeListing}
\index{prime.asm|)}
