
\chapter{Linguagem de Assembly Básica}

\section{Trabalhando com Inteiros \index{integer|(}}

\subsection{Representação de Inteiros \index{integer!representation|(}}

\index{integer!unsigned|(}
Inteiros vêm em dois sabores: sem sinal e com sinal. Inteiros sem sinal (que 
são não negativos) são representados de uma maneira bem direta em binário.
O número 200 como um inteiro sem sinal de um byte seria representado por
11001000 (ou C8 em hex).
\index{integer!unsigned|)}

\index{integer!signed|(}
Inteiros com sinal (que podem ser positivo ou negativo) são representados de maneira
mais complicada. Por exemplo, considere $-56$. $+56$ como um byte seria
representado por 00111000. Na teoria, poderíamos representar $-56$ como $-111000$,
mas como isso seria representado em um byte na memória do computador?
Como o sinal negativo seria alocado?

Existem três técnicas gerais que vêm sendo usada para representar
inteiros com sinal na memória do computador. Todos estes métodos usam o bit
mais significativo do inteiro como um \emph{bit
de sinal}. \index{integer!sign bit} Este bit será 0 se o número for positivo
e 1 se for negativo.

\subsubsection{Sinal-e-magnitude \index{integer!representation!signed magnitude}}

O primeiro método é o mais simples e se chama \emph{sinal-e-magnitude} (ou sinal-magnitude). Ele 
representa o inteiro como duas partes. A primeira parte é o bit de sinal e 
a segunda parte é a magnitude do inteiro. Neste caso, 56 seria representado como
o byte $\underline{0}0111000$ (o bit de sinal está sublinhado) e $-56$
seria $\underline{1}0111000$. O maior valor de byte seria
$\underline{0}1111111$ ou $+127$ e o menor valor de byte seria 
$\underline{1}1111111$ ou $-127$. Para negar um valor, o bit de sinal é invertido.
Este método é direto, mas tem suas desvantagens. Primeiro,
há dois possíveis valores de zero, $+0$ ($\underline{0}0000000$) e
$-0$ ($\underline{1}0000000$). Como zero não é positivo nem negativo,
ambas representações devem agir da mesma forma. Isto complica a lógica 
da arimética da CPU. Segundo, aritmética geral é também complicada.
Se 10 é adicionado a $-56$, isso deve ser reformulado como 10 subtraído de 56. Novamente,
isso complica a lógica da CPU.

\subsubsection{Complemento para um \index{integer!representation!one's complement}}
O segundo método é conhecido como \emph{complemento para um}. O
complemento para um de algum número é encontrado ao inverter cada bit no número.
(Outra forma de compreender isso é que o novo valor de bit será $1 - \mathrm{antigo valor de bit}$.) 
Por exemplo, o complemento para um de 
$\underline{0}0111000$ ($+56$) é $\underline{1}1000111$. Na notação de complemento
para um, calcular o complemento para um é equivalente a negação. Assim,
$\underline{1}1000111$ é a representação para $-56$. Note que o bit de 
sinal foi alterado automaticamente pelo complemento para um e como é de se esperar 
tomar o complemento para um duas vezes produz o número original. Assim como no
primeiro método, existem duas representações de zero: 
$\underline{0}0000000$ ($+0$) e $\underline{1}1111111$ ($-0$). Artimética 
com o complemento para um é complicada.

Há um truque útil para encontrar o complemento para um de um número em
hexadecimal sem convertê-lo em binário. O truque é subtrair o dígito
hex do F (ou 15 in decimal). Este método assume que o número de
bits no número é um múltiplo de 4. Tome como exemplo: $+56$ é
representado por 38 em hex. Para encontrar seu complemento para um, subtraia cada
dígito de F para conseguir C7 em hex. Isso esta coerente com o resultado acima.

\subsubsection{Complemento para dois \index{integer!representation!two's complement|(}
               \index{two's complement|(}}

Os primeiros dois métodos descritos eram usados em computadores antigos. Computadores modernos
usam um terceiro método chamado \emph{complemento para dois}. O complemento
para dois de um número é encontrado a partir de dois passos:
\begin{enumerate}
\item Encontre o complemento para um do número em questão
\item Adicione um ao resultado encontrado no item anterior
\end{enumerate}
Veja um exemplo com $\underline{0}0111000$ (56). Primeiro calculamos o
complemento para um: $\underline{1}1000111$. Depois adicionamos um ao resultado:
\[
\begin{array}{rr}
 & \underline{1}1000111 \\
+&                    1 \\ \hline
 & \underline{1}1001000
\end{array}
\]

Na notação de complemento para dois, calcular o complemento para dois é equivalente
a negar um número. Portanto, $\underline{1}1001000$ é a representação do complemento
para dois de $-56$. Duas negações devem reproduzir o número original.
Surpreendentemente complemento para dois atende a este requisito. Tome o complemento
para dois de $\underline{1}1001000$ adicionando um ao complemento para um.
\[
\begin{array}{rr}
 & \underline{0}0110111 \\
+&                    1 \\ \hline
 & \underline{0}0111000
\end{array}
\]

Quando realizamos a adição numa operação de complemento para dois, a adição
do bit mais à esquerda pode produzir um carry. Este carry \emph{não} é usado. 
Lembre-se que todos os dados no computador são de algum tamanho fixo (em termos de 
números de bits). Adicionar dois bytes sempre produz um byte como resultado (assim
como unir duas palavras produz uma palavra, {\em etc\/}.) Esta propriedade é importante 
para a notação de complemento para dois. Por exemplo, considere zero como um número de
complemento para dois de um byte ($\underline{0}0000000$). Calcular seu complemento para dois
resulta na soma:
\[
\begin{array}{rr}
 & \underline{1}1111111 \\
+&                    1 \\ \hline
c& \underline{0}0000000
\end{array}
\]
em que $c$ representa um carry. (Posteriormente será mostrado como detectar este carry,
porém ele não é alocado no resultado.) Assim, na notação de complemento para dois existe
apenas um zero. Isto faz a aritmética de complemento para dois ser mais simples do que aquelas 
dos métodos anteriores.

\begin{table}
\centering
\begin{tabular}{||c|c||}
\hline
Número & Representação Hex \\
\hline
0 & 00 \\
1 & 01 \\
127 & 7F \\
-128 & 80 \\
-127 & 81 \\
-2 & FE \\
-1 & FF \\
\hline
\end{tabular}
\caption{Representação de Complemento para Dois \label{tab:twocomp}}
\end{table}

Usando a notação de complemento para dois, um byte com sinal pode ser usado para
representar os números de $-128$ a $+127$. A tabela~\ref{tab:twocomp} mostra alguns
valores selecionados. Se são usados 16 bits, os números com sinal de $-32,768$ a 
$+32,767$ podem ser representados. $+32,767$ é representado por 7FFF, 
$-32,768$ por 8000, -128 por FF80 e -1 por FFFF. Os números de 32 bit em complemento 
para dois no intervalo de $-2$ bilhões a $+2$ bilhões aproximadamente. 


A CPU tem ideia nenhuma idea do que um byte em particular (ou palavra ou palavra dupla) 
deveria representar. Assembly não possui a ideia de tipos que uma
linguagem de alto nível possui. A interpretação dos dados depende de qual instrução
é usada com o dado. Se o valor hex FF será considerado para representar
um número com sinal $-1$ ou um número sem sinal $+255$ dependerá da programadora. A linguagem C 
define tipos de inteiro com sinal e sem sinal. Isso permite um compilador de C a 
determinar a instrução correta a ser usada com o dado.

\index{two's complement|)}
\index{integer!representation!two's complement|)}
\index{integer!signed|)}

\subsection{Extensão de sinal \index{integer!sign extension|(}}

Em assembly, todo dado tem um tamanho específico. Não é incomum ter de precisar 
mudar o tamanho de um dado para usá-lo com outro dado. Reduzir o tamanho é o 
mais fácil.

\subsubsection{Reduzindo o tamanho de dados}

Para reduzir o tamanho do dado, basta remover os bits mais significativos do
dado. Veja um exemplo trivial:
\begin{AsmCodeListing}[numbers=none,frame=none]
      mov    ax, 0034h      ; ax = 52 (alocado 16 bits)
      mov    cl, al         ; cl = 8-bits a menos do que ax
\end{AsmCodeListing}

Claro, se o número não puder ser representado corretamente no tamanho
menor, reduzir o tamanho não irá funcionar. Por exemplo, se {\code AX}
for 0134h (ou 308 em decimal) então o código acima ainda armazenaria 
{\code CL} para 34h. Este método funciona tanto para números com sinal
quanto para números sem sinal. Considere números com sinal, se {\code AX} for FFFFh ($-1$ como uma
palavra), então {\code CL} seria FFh ($-1$ como um byte). Entretanto, note
que isto não é correto se o valor em {\code AX} for sem sinal!

A regra para números sem sinal é que todos os bits a serem removidos devem
ser 0 para a conversão ser correta. A regra para números com sinal é
que os bits a serem removidos devem ser ou todos 1 ou todos 0. Ademais,
o primeiro bit não removido deve ter o mesmo valor que os bits
removidos. Este bit será o novo bit de sinal do valor de tamanho menor.
É importante que seja igual ao bit de sinal do valor original!

\subsubsection{Aumentando o tamanho de dados}

Aumentar o tamanho do dado é mais complicado do que
reduzir. Considere o hex byte FF. Caso ele seja estendido para uma palavra,
qual valor a palavra deveria ter? Isso depende da forma como FF é
interpretada. Se FF é um byte sem sinal (255 em decimal), então a palavra
deverá ser 00FF; contudo, se for um byte com sinal ($-1$ em decimal),
então a palavra será FFFF.

Em geral, para estender um número sem sinal, faça todo os novos bits
do número expandido serem 0 (zeros). Deste modo, FF torna-se 00FF. Entretando, para estender um
número com sinal, deverá \emph{estender} o bit de sinal. 
\index{integer!sign bit} Isso quer dizer que os novos bits tornam-se
cópias do bit de sinal. Como o bit de sinal de FF é 1, os novos bits
também devem ser uns, para produzir FFFF. Caso extendêssemos o número com sinal 5A (90 in
decimal), o resultado seria 005A.

Existem várias instruções que o 80386 providencia para a estenção de
números. Lembre-se que o computador não sabe quando um número é com sinal
ou sem sinal. Vai da programadora utilizar a instrução correta.

Para números com sinal, pode-se simplesmente posicionar zeros nos bits superiores usando
a instrução {\code MOV}. Por exemplo, para estender o byte em AL para uma palavra 
sem sinal em AX:
\begin{AsmCodeListing}[numbers=none,frame=none]
      mov    ah, 0   ; zere 8-bits superiores
\end{AsmCodeListing}
Entretanto, não é possível utilizar a instrução {\code MOV} para
converter palavra sem sinal em AX em uma palavra dupla sem sinal em EAX. Por
que não? Bom, não há como especificar os 16 bits superiores de EAX em uma {\code
MOV}. O 80386 soluciona este problema providenciando uma nova instrução
{\code MOVZX}. \index{MOVZX} Esta instrução tem dois operandos. O destino
(primeiro operando) deve ser um registrador de 16 ou 32~bit.  A fonte (segundo
operando) pode ser um registrador de 8 ou 16~bit ou um byte ou palavra de 
memória. A outra restrição é que o destino deve ser maior do que
a fonte. (Maioria das instruções requer que a fonte e o destino tenham
o mesmo tamanho.) Aqui vão alguns exemplos:
\begin{AsmCodeListing}[numbers=none,frame=none]
      movzx  eax, ax      ; estende ax em eax
      movzx  eax, al      ; estende al em eax
      movzx  ax, al       ; estende al em ax
      movzx  ebx, ax      ; estende ax em ebx
\end{AsmCodeListing}

Para números com sinal, não há maneira fácil de utilizar a instrução {\code MOV}. 
O 8086 providencias diversas instruções para estender
números com sinal.  A instrução {\code CBW} \index{CBW} (Convert Byte to
Word) estende o registrador AL em AX. Os operandos
estão implícitos. A instrução {\code CWD} \index{CWD} (Convert Word to Double
word) estende AX em DX:AX. A notação DX:AX significa
enxergar os registradores DX e AX como um registrador de 32~bit com os
 16 bits superiores em DX e os bits inferiores em AX. (Lembre-se que o 8086
não possui nenhum registrador de 32~bit!) O 80386 adicionou várias novas
instruções. A instrução {\code CWDE} \index{CWDE} (Convert Word to Double
word Extended) estende AX em EAX. A instrução {\code CDQ}
\index{CDQ} (Convert Double word to Quad word) 
estende EAX em EDX:EAX\index{register!EDX:EAX} (64~bits!). Finalmente, a
instrução {\code MOVSX} \index{MOVSX} funciona similar a {\code MOVZX}
exceto pelo fato de usar as regras para números com sinal.

\subsubsection{Aplicação para programação em C}

Estender \MarginNote{ANSI C não define se o tipo {\code char}
é com sinal ou não, vai de cada compilador decidir
isto. Este é o motivo do tipo ser explicitamente definido em
Figure~\ref{fig:charExt}.} inteiros com e sem sinal também ocorrem
em C. Variáveis em C podem ser declaradas como como sinal ou sem sinal
({\code int} é com sinal). Considere o código em 
Figure~\ref{fig:charExt}.  Na linha~3, a variável {\code a} é
estendida por meio das regras para valores sem sinal (usando {\code MOVZX}), mas na 
linha~4, as regras para valores com sinal é utilizada em {\code b} (usando {\code MOVSX}).

\begin{figure}[t]
\begin{lstlisting}[frame=tlrb]{}
unsigned char uchar = 0xFF;
signed char   schar = 0xFF;
int a = (int) uchar;     /* a = 255 (0x000000FF) */
int b = (int) schar;     /* b = -1  (0xFFFFFFFF) */
\end{lstlisting}
\caption{}
\label{fig:charExt}
\end{figure}

Há um erro comum na programação em C diretamente relacionado com este assunto.
Considere o código em Figure~\ref{fig:IObug}. O protótipo de 
{\code fgetc()}{\samepage é:
\begin{CodeQuote}
int fgetc( FILE * );
\end{CodeQuote}
Alguém poderia se perguntar }Por que a função retorna um {\code int}
sendo que lê caracteres? A razão é que normalmenta ela retorna
um {\code char} (estendido em um valor {\code int} utilizando a extenção
zero). Contudo, existe um valor possível de ser retornado que não é
um caractere, {\code EOF}. Este é um macro usualmente definido como 
$-1$. Portando, {\code fgetc()} retorna ou um {\code char}
estendido em um {\code int} (que é como {\code 000000{\em
xx}} em hex) ou {\code EOF} (que é como {\code FFFFFFFF} em
hex).

\begin{figure}[t]
\begin{lstlisting}[stepnumber=0,frame=tlrb]{}
char ch;
while( (ch = fgetc(fp)) != EOF ) {
  /* do something with ch */
}
\end{lstlisting}
\caption{}
\label{fig:IObug}
\end{figure}

O principal problema com o programa em Figure~\ref{fig:IObug} é que
{\code fgetc()} retorna um {\code int}, mas este valor é alocado em um
{\code char}. C irá truncar os bits de ordem superior para se adequar o valor {\code
int} no {\code char}. O único problema é que ambos os números
(em hex) {\code 000000FF} e {\code FFFFFFFF} serão truncados
para o byte {\code FF}. Desta forma, o ciclo while não pode ser distinguido 
entre o byte {\code FF} do arquivo e o fim do arquivo.

O que exatamente o código faz neste caso, depende de o {\code char} ser
com ou sem sinal. Por quê? Porque na linha~2, {\code ch} é comparado com 
{\code EOF}. Dado que {\code EOF} é um valor {\code int}\footnote{É um
conceito errôneo comum pensar que arquivos possuem um caractere EOF em seu final. Isto
\emph{não} é verdade!}, {\code ch} será
estendido em um {\code int} de forma que os dois valores comparados são do 
mesmo tamanho\footnote{O motivo desse requerimento será demonstrado posteriormente.}.
Como mostrado por Figure~\ref{fig:charExt}, a variável ser com ou sem sinal 
é bastante importante.

Caso {\code char} seja sem sinal, {\code FF} é estendido para {\code
000000FF}. Isto é comparado com {\code EOF} ({\code FFFFFFFF}) e
resulta em não ser igual. Assim, o ciclo nunca acaba!

Caso {\code char} é com sinal, {\code FF} é estendido para {\code
FFFFFFFF}. Isto é comparado como igual e o ciclo tem fim. Contudo,
como o byte {\code FF} pode ter sido lido do arquivo, o ciclo 
pode ter terminado prematuramente.

A solução para este problema é definir a variável {\code ch} como um
{\code int}, não como um {\code char}. Quando isto é feito, não há truncamento ou
extenção na linha~2. Dentro do ciclo, é seguro truncar o
valor já que {\code ch} \emph{deve} de fato ser um simples byte ali.

\index{integer!sign extension|)}
\index{integer!representation|)}

\subsection{Aritmética de complemento para dois \index{two's complement!arithmetic|(}}

Como visto anteriormente, a instrução {\code add} efetua adição e
a instrução {\code sub} efetua a subtração. Dois dos bits nos
registradores FLAGS que são alterados por estas instruções são as bandeiras \emph{overflow}
e \emph{carry}. A bandeira overflow é alterada caso o resultado verdadeiro da
operação for grande demais para caber no destino reservado para artimética 
com sinal. A bandeira carry é alterada se há um carry no bit mais significativo da
adição ou um empréstimo no bit mais significativo da subtração. Deste modo, pode se usar
para detectar overflow para aritmética sem sinal. O uso da bandeira carry 
para aritmética com sinal será bisto brevemente. Uma das grandes vantagens
do complemento para dois é que as regras para adição e 
para subtração são exatamente as mesmas para os inteiros sem sinal. Assim,
{\code add} e {\code sub} podem ser utilizados em inteiro com ou sem 
sinal.
\[
\begin{array}{rrcrr}
 & 002\mathrm{C} & & & 44\\
+& \mathrm{FFFF} & &+&(-1)\\ \cline{1-2} \cline{4-5}
 & 002\mathrm{B} & & & 43
\end{array}
\]
Há um carry gerado, mas não faz parte da resposta.

\index{integer!multiplication|(}
\index{MUL|(}
\index{IMUL|(}
Existem duas instruções diferentes para multiplicação e para divisão. Primeiro, para
multiplicar utiliza-se a instrução {\code MUL} ou {\code IMUL}. A
instrução {\code MUL} é usada para multiplicar números sem sinal e
{\code IMUL} é utilizada para multiplicar inteiros com sinal. Por que são
necessárias duas instruções diferentes? As regras para multiplicação são
diferentes para números sem sinal e números complemento para dois com sinal. Como?
Considere a multiplicação do byte FF por ele mesmo produzindo uma palavra
como resultado. Utilizando a multiplicação sem sinal isto é 255 vezes 255 ou 65025
(ou FE01 em hex). Utilizando a multiplicação com sinal isto é $-1$ vezes $-1$ ou
1 (ou 0001 em hex).

Há várias maneiras das instruções de multiplicação. A maneira mais 
antiga é como:
\begin{AsmCodeListing}[numbers=none,frame=none]
      mul   source
\end{AsmCodeListing}
A \emph{fonte} é ou um registrador ou uma referência de memória. A fonte não pode ser  
um valor imediato. Qual multiplicação exatamente é efetuada depende do
tamanho do operando da fonte. Se o operando é do tamanho de byte, este é multiplicado pelo
byte no registrador AL e o resultado é alocado em 16 bits de AX.
Caso a fonte seja 16-bit, este é multiplicado pela palavra em AX e o resultado de 32-bit
é alocado em DX:AX. Se a fonte é 32-bit, este é multiplicado por EAX
e o resultado de 64-bit é alocado em EDX:EAX\index{register!EDX:EAX}.
\index{MUL|)}

\begin{table}[t]
\centering
\begin{tabular}{|c|c|c|l|}
\hline
{ \bf dest} & { \bf source1 } & {\bf source2} & \multicolumn{1}{c|}{\bf Action} \\ \hline
            & reg/mem8        &               & AX = AL*source1 \\
            & reg/mem16       &               & DX:AX = AX*source1 \\
            & reg/mem32       &               & EDX:EAX = EAX*source1 \\
reg16       & reg/mem16       &               & dest *= source1 \\
reg32       & reg/mem32       &               & dest *= source1 \\
reg16       & immed8          &               & dest *= immed8 \\
reg32       & immed8          &               & dest *= immed8 \\
reg16       & immed16         &               & dest *= immed16 \\
reg32       & immed32         &               & dest *= immed32 \\
reg16       & reg/mem16       & immed8        & dest = source1*source2 \\
reg32       & reg/mem32       & immed8        & dest = source1*source2 \\
reg16       & reg/mem16       & immed16       & dest = source1*source2 \\
reg32       & reg/mem32       & immed32       & dest = source1*source2 \\
\hline
\end{tabular}
\caption{{\code imul} Instructions \label{tab:imul}}
\end{table}

A instrução {\code IMUL} possui o mesmo formato que {\code MUL}, porém também 
adiciona alguns outros formatos de instrução. Existem formatos de dois e três operandos:
\begin{AsmCodeListing}[numbers=none,frame=none]
      imul   dest, source1
      imul   dest, source1, source2
\end{AsmCodeListing}
Table~\ref{tab:imul} mostra as possíveis combinações.
\index{IMUL|)}
\index{integer!multiplication|)}

\index{integer!division|(}
\index{DIV}
Os dois operadores da divisão são {\code DIV} e {\code IDIV}. Eles efetuam a
divisão de inteiros com e sem sinal, respectivamente. O formato geral é:
\begin{AsmCodeListing}[numbers=none,frame=none]
      div   source
\end{AsmCodeListing}
Se a fonte é 8-bit, então AX será dividido pelo operando. O
quociente é alocado em AL e o resto em AH. Caso a fonte seja 
16-bit, então DX:AX é dividido pelo operando. O quociente é alocado
em AX e o resto em DX. Se a fonte é 32-bit, então
EDX:EAX\index{register!EDX:EAX} é dividido pelo operando e o quociente é
alocado para EAX e o resto para EDX. A instrução {\code IDIV}
\index{IDIV} funciona de modo similar. Não existe instruções especiais de
{\code IDIV} como as específicas de {\code IMUL}. Caso o quociente
seja grande demais para caber em seu registrador ou o divisor é zero,
o programa é interrompido e termina. Um erro comum é esquecer
de iniciar DX ou EDX antes da divisão.
\index{integer!division|)}

A instrução {\code NEG} \index{NEG} nega seu operando calculando seu
complemento para dois. Seu operando pode ser qualquer registrador de 8-bit, 16-bit, ou 32-bit
ou lugar na memória.

\subsection{Programa de exemplo}
\index{math.asm|(}
\begin{AsmCodeListing}[label=math.asm]
%include "asm_io.inc"
segment .data         ; Output strings
prompt          db    "Digite um número: ", 0
square_msg      db    "O quadro do número é ", 0
cube_msg        db    "O cubo do número é ", 0
cube25_msg      db    "O cubo do número vezes 25 é ", 0
quot_msg        db    "Quociente do cubo/100 é ", 0
rem_msg         db    "Resto do cube/100 é ", 0
neg_msg         db    "A negação do resto é ", 0

segment .bss
input   resd 1

segment .text
        global  _asm_main
_asm_main:
        enter   0,0               ; rotina inicial
	pusha

        mov     eax, prompt
        call    print_string

        call    read_int
        mov     [input], eax

        imul    eax               ; edx:eax = eax * eax
        mov     ebx, eax          ; salvar resposta em ebx
        mov     eax, square_msg
        call    print_string
        mov     eax, ebx
        call    print_int
        call    print_nl

        mov     ebx, eax
        imul    ebx, [input]      ; ebx *= [input]
        mov     eax, cube_msg
        call    print_string
        mov     eax, ebx
        call    print_int
        call    print_nl

        imul    ecx, ebx, 25      ; ecx = ebx*25
        mov     eax, cube25_msg
        call    print_string
        mov     eax, ecx
        call    print_int
        call    print_nl

        mov     eax, ebx
        cdq                       ; inicia edx com a extenção de sinal
        mov     ecx, 100          ; não pode dividir pelo valor imediato
        idiv    ecx               ; edx:eax / ecx
        mov     ecx, eax          ; salvar quociente em ecx
        mov     eax, quot_msg
        call    print_string
        mov     eax, ecx
        call    print_int
        call    print_nl
        mov     eax, rem_msg
        call    print_string
        mov     eax, edx
        call    print_int
        call    print_nl
        
        neg     edx               ; negar o resto
        mov     eax, neg_msg
        call    print_string
        mov     eax, edx
        call    print_int
        call    print_nl

        popa
        mov     eax, 0            ; retorne a C
        leave                     
        ret
\end{AsmCodeListing}
\index{math.asm|)}

\subsection{Aritmética de precisão estendida \label{sec:ExtPrecArith} \index{integer!extended precision|(}}}

A linguagem Assembly também fornece instruções que permitem efetuar
adição e subtração de números maiores do que palavras dupla. Estas
instruções utilizam a bandeira carry. Como dito acima, ambas instruções {\code ADD}
\index{ADD} e {\code SUB} \index{SUB} modificam a bandeira carry
se um carry ou empréstimo são gerados, respectivamente. Essa
informação alocada na bandeira flag pode ser usada para adicionar ou subtrair
números maiores quebrando a operação em partes de palavras duplas
ou, simplesmente, em partes menores.

As instruções {\code ADC} \index{ADC} e {\code SBB} \index{SBB} 
utilizam essa informação na bandeira carry. A instrução {\code ADC} 
efetua a seguinte operação:
\begin{center}
{\code \emph{operand1} = \emph{operand1} + bandeira carry + \emph{operand2} }
\end{center}
A instrução {\code SBB} efetua:
\begin{center}
{\code \emph{operand1} = \emph{operand1} - bandeira carry - \emph{operand2} }
\end{center}
Como estas são utilizadas? Considere a soma de inteiros de 64-bit em
EDX:EAX\index{register!EDX:EAX} e EBX:ECX. O código a seguir poderia alocar
a soma em EDX:EAX:
\begin{AsmCodeListing}[frame=none]
      add    eax, ecx       ; soma os 32-bits inferiores
      adc    edx, ebx       ; soma os 32-bits superiores e o carry da soma anterior
\end{AsmCodeListing}
A subtração é bem similar. O seguinte código subtrai EBX:ECX de 
EDX:EAX:
\begin{AsmCodeListing}[frame=none]
      sub    eax, ecx       ; subtrai os 32-bits inferiores
      sbb    edx, ebx       ; subtrai os 32-bits superiores e o empréstimo
\end{AsmCodeListing}

Para número \emph{realmente} maiores, um ciclo pode ser utilizado (veja 
Section~\ref{sec:control}). Para um ciclo de soma, seria conviniente usar a
instrução {\code ADC} para cada interação (ao invés de todas menos a primeira 
interação). Isso pode ser feito utilizando a instrução {\code CLC} \index{CLC} (CLear Carry)
logo antes do ciclo começar a inicializar a bandeira flag a 0.
Se a bandeira carry flag for 0, não há diferença entre as instruções {\code ADD} e
{\code ADC}. A mesma ideia pode ser usada para subtração, também.
\index{integer!extended precision|)}
\index{two's complement!arithmetic|)}

\section{Estruturas de Controle}
\label{sec:control}
Linguagens de alto nível fornecem controles de estrutura de alto nível (\emph{i.e.}, as
instruções \emph{if} e \emph{while}) que controlam o fio de execuções.
A linguagem Assembly não fornece tais controles de estruturas complexos. Ao invés, ela
utiliza a infame \emph{goto} e se usada de forma inapropriada pode resultar em
código spaghetti! Entretando, \emph{é} possível escrever códigos estruturados
na linguagem assembly. O procedimento básico é desenhar a lógica do programa utilizando
as estruturas de controle de alto nível familiares e traduzir o desenho para
a linguagem de assembly apropriada (similar ao que um compilador faria).

\subsection{Comparações \index{integer!comparisons|(} \index{CMP|(}}
%TODO: Make a table of all the FLAG bits

\index{register!FLAGS|(}
Estruturas de controle decidem o que vão fazer baseado em comparação de dados. Em
assembly, o resultado de uma comparação é alocado nos registradores FLAGS 
para serem usados posteriormente. O 80x86 fornece a instrução {\code CMP} para
efetuar as comparações. O registrador FLAGS é baseado na
diferença entre dois operandos da instrução {\code CMP}. Os
operandos são subtraídos e o FLAGS é definido com base no resultado, mas
o resultado \emph{não} é alocado em lugar algum. Se você necessita do resultado, utilize
a SUB ao invés da instrução {\code CMP}.

\index{integer!unsigned|(}
Para inteiros sem sinal, existem duas bandeiras (bits no registrador 
FLAGS) que são importantes: zero (ZF) \index{register!FLAGS!ZF} e carry (CF) 
\index{register!FLAGS!CF}. A bandeira
zero é definida (1) se a diferença resultante for zero. A bandeira
carry é utilizada como bandeira de empréstimo para a subtração. Considere a
comparação como:
\begin{AsmCodeListing}[frame=none, numbers=none]
      cmp    vleft, vright
\end{AsmCodeListing}
A diferença de {\code vleft~-~vright} é calculada e as bandeiras são
definidas de acordo. Se a diferença de {\code CMP} é zero, {\code 
vleft~=~vright}, então a ZF é definida (\emph{i.e.} 1) e a CF é não definida
(\emph{i.e.} 0). Se {\code vleft~>~vright}, então ZF não é definida e CF
não é definida (não há empréstimo). Caso {\code vleft~<~vright}, então ZF não é definida e
CF é definida (empréstimo).
\index{integer!unsigned|)}

\index{integer!signed|(} 
Para inteiros com sinal, existem três bandeiras
que são importantes: zero \index{register!FLAGS!ZF} (ZF),
overflow \index{register!FLAGS!OF}(OF) e a bandeira sign
\index{register!FLAGS!SF} (SF). \MarginNote{Por que fazer SF~=~OF se
{\code vleft~>~vright}? Se não tiver nenhum overflow, então a diferença
terpa i valor correto e deverá ser não-negativa. Assim,
SF~=~OF~=~0. Entretando, se houver um overflow, a diferença não
terá o valor correto (e será, na verdade, negativa). Logo,
SF~=~OF~=~1.}A bandeira overflow é definida se o resultado da operação
transbordar (ou underflows). A bandeira sign é definida caso o resultado de uma
operação é negativo. Se {\code vleft~=~vright}, a ZF é definida (assim
como para inteiros sem sinal). Se {\code vleft~>~vright}, ZF não é definida e
SF~=~OF.  Se {\code vleft~<~vright}, ZF não é definida e SF~$\neq$~OF.
\index{integer!signed|)}

Não esqueça que outras instruções também podem mudar o registrador FLAGS, 
não apenas a {\code CMP}.
\index{CMP|)}
\index{integer!comparisons|)}
\index{register!FLAGS|)}
\index{integer|)}

\subsection{Instruções de ramificação}

Instruções de ramificação podem transferir a execução para pontos arbitrários de um programa.
Em outras palavras, podem agir como a \emph{goto}. Existem dois tipos de ramificação:
incondicional e condicional. Uma ramificação incondicional é como a goto,
sempre realiza a ramificação. Uma ramificação condicional pode ou não fazer a
ramificação a depender das bandeiras no registrador FLAGS. Caso a ramificação condicional 
não fizer a ramificação, o controle passa para a próxima instrução.

\index{JMP|(}
A instrução {\code JMP} (short for \emph{jump}) faz
ramificações incondicionais. Seu argumento normalmente é uma \emph{etiqueta
de código} da instrução a qual deve ramificar. O assembler ou linker irá
substituir a etiqueta com o endereço correto da instrução. Esta é mais uma
operação tediosa que o assembler faz para tornar a
vida do programador mais fácil. É importante perceber que a instrução
logo depois da instrução {\code JMP} nunca será executada
a menos que outras instrução ramifique em direção a ela!

Existem várias variações da instrução jump:
\begin{description}

\item[SHORT] Este salto é bem limitado em questão de intervalo. Ele pode apenas mover 128 bytes para cima
ou para baixo na memória. A vantagem desse tipo é utilizar menos
memória do que os outros. Ele usa um único byte com sinal para alocar o 
\emph{deslocamento} do salto. O deslocamento é quanto bytes se move para cima 
ou para trás. (O deslocamento é adicionado a EIP). Para especificar um salto
short, use a palavra-chave {\code SHORT} exatamente antes da etiqueta
na instrução {\code JMP}.

\item[NEAR] Este salto é o tipo padrão tanto para ramificações incondicionais quanto 
para condicionais, ele pode ser utitlizado para pular para qualquer lugar no
seguimento. Na verdade, 80386 suporta dois tipos de salto near. Um
usa dois bytes para o deslocamento. Isso permite mover para cima ou
para baixo exatos 32,000 bytes. O outro tipo usa quatro bytes para o
deslocamento, o que claramento permite se mover para cima ou para baixo a qualquer lugar no 
seguimento de código. O tipo de quatro byte é o padrão no modo protegido de 386. 
O tipo dois byte pode ser especificado colocando a palavra-chave {\code WORD}
antes da etiqueta na instrução {\code JMP}.

\item[FAR] Este salto permite controle para mover a outro seguimento de código. Isso é algo
raro de se fazer no modo protegido 386.
\end{description}

As etiquetas de código válidas seguem as mesmas regras das etiquetas de dado. Etiquetas de código
são definidas are defined colocando-as no seguimento de código na frente da instrução que
elas rotulam. Um dois pontos é posto ao final da etiqueta no ponto de definição. 
Os dois pontos \emph{não} são parte do nome.
\index{JMP|)}

\index{conditional branch|(}
\begin{table}[t]
\center
\begin{tabular}{|ll|}
\hline
JZ  & salta somente se ZF é definida \\
JNZ & salta somente se ZF não é definida \\
JO  & salta somente se OF é definida \\
JNO & salta somente se OF não é definida \\
JS  & salta somente se SF é definida \\
JNS & salta somente se SF não é definida \\
JC  & salta somente se CF é definida \\
JNC & salta somente se CF não é definida \\
JP  & salta somente se PF é definida \\
JNP & salta somente se PF não é definida \\
\hline
\end{tabular}
\caption{Simple Conditional Branches \label{tab:SimpBran} \index{JZ} \index{JNZ}
        \index{JO} \index{JNO} \index{JS} \index{JNS} \index{JC} \index{JNC}
        \index{JP} \index{JNP}}
\end{table}

Há muitas instruções de ramificação condicional diferentes. Elas também
tomam uma etiqueta de código como seu único operando. As mais simples olham apenas
para uma bandeira no registrador FLAGS para determinar se saltam ou
não. Veja Table~\ref{tab:SimpBran} para uma listas destas
instruções. (PF é a \emph{bandeira parity} \index{register!FLAGS!PF}
que indica se o número de bits definidos nos 8-bits inferiores do resultado
é par ou ímpar.)

O seguinte pseudo-código:
\begin{Verbatim}
if ( EAX == 0 )
  EBX = 1;
else
  EBX = 2;
\end{Verbatim}
poderia ser escrito em assembly como:
\begin{AsmCodeListing}[frame=none]
      cmp    eax, 0            ; define bandeiras (ZF definida caso eax - 0 = 0)
      jz     thenblock         ; se ZF é definida então salta para thenblock
      mov    ebx, 2            ; ELSE parte de IF
      jmp    next              ; salta sobre a parte de THEN do IF
thenblock:
      mov    ebx, 1            ; THEN parte de IF
next:
\end{AsmCodeListing}

Outras comparações não são tão simples utilizando ramificações condicionais 
Table~\ref{tab:SimpBran}. Para demonstrar, considere o seguinte pseudo-código:
\begin{Verbatim}
if ( EAX >= 5 )
  EBX = 1;
else
  EBX = 2;
\end{Verbatim}
Se EAX for maior ou igual a cinco, a ZF pode ou não ser definida e SF
será igual a OF. Veja agora o código em assembly que testa estas condicionais 
(assumindo que EAX é com sinal):
\begin{AsmCodeListing}[frame=none]
      cmp    eax, 5
      js     signon            ; goto signon se SF = 1
      jo     elseblock         ; goto elseblock se OF = 1 e SF = 0
      jmp    thenblock         ; goto thenblock se SF = 0 e OF = 0
signon:
      jo     thenblock         ; goto thenblock se SF = 1 e OF = 1
elseblock:
      mov    ebx, 2
      jmp    next
thenblock:
      mov    ebx, 1
next:
\end{AsmCodeListing}

\begin{table}
\center
\begin{tabular}{|ll|ll|}
\hline
\multicolumn{2}{|c|}{\textbf{Com sinal}} & \multicolumn{2}{c|}{\textbf{Sem sinal}} \\
\hline
JE & salta se {\code vleft = vright} & JE & salta se {\code vleft = vright} \\
JNE & salta se {\code vleft $\neq$ vright} & JNE & salta se {\code vleft $\neq$ vright} \\
JL, JNGE & salta se {\code vleft < vright} & JB, JNAE & salta se {\code vleft < vright} \\
JLE, JNG & salta se {\code vleft $\leq$ vright} & JBE, JNA & salta se {\code vleft $\leq$ vright} \\
JG, JNLE & salta se {\code vleft > vright} & JA, JNBE & salta se {\code vleft > vright} \\
JGE, JNL & salta se {\code vleft $\geq$ vright} & JAE, JNB & salta se {\code vleft $\geq$ vright} \\
\hline
\end{tabular}
\caption{Instruções de Comparação Com Sinal e Sem Sinal \label{tab:CompBran} \index{JE} \index{JNE}
         \index{JL} \index{JNGE} \index{JLE} \index{JNG} \index{JG} \index{JNLE} \index{JGE}
         \index{JNL}}
\end{table}

O código a cima é bem estranho. Felizmente, o 80x86 fornece instruções de
ramificação adicionais a fim de tornar estes tipos de testes \emph{muito} mais fáceis. Existem
versões com e sem sinal de cada uma. Tabela~\ref{tab:CompBran} mostra
estas instruções. Os saltos igual e não-igual (JE e JNE) são 
os mesmo para inteiros com e sem sinal. (Na verdade, JE e JNE são exatamente
idênticos a JZ e JNZ, respectivamente.) Cada uma das outras instruções de 
ramificação tem dois sinônimos. Por exemplo, observe JL (jump less than) e
JNGE (jump not greater than or equal to). Estas são instruções similares
pois:
\[ x < y \Longrightarrow \mathbf{not}( x \geq y ) \]
A ramificação sem sinal utiliza A para \emph{acima} e B para \emph{abaixo} ao invés de
L e G.

Utilizando estas instruções de salto, o pseudo-código acima pode ser facilmente traduzido
para assembly.
\begin{AsmCodeListing}[frame=none]
      cmp    eax, 5
      jge    thenblock
      mov    ebx, 2
      jmp    next
thenblock:
      mov    ebx, 1
next:
\end{AsmCodeListing}
\index{conditional branch|)}

\subsection{As Instruções de Ciclo (loop)}

O 80x86 oferece diversas instruções desenhadas para implementar 
ciclos como os de \emph{for}. Cada uma destas instruções leva uma etiqueta
de código como seu operando.
\begin{description}
\item[LOOP] 
\index{LOOP}
Decrementa ECX, se ECX $\neq$ 0, salta para etiqueta
\item[LOOPE, LOOPZ]
\index{LOOPE} \index{LOOPZ}
Decrementa ECX (registrador FLAGS não é modificado), se
                    ECX $\neq$ 0 e ZF = 1, salta
\item[LOOPNE, LOOPNZ]
\index{LOOPNE} \index{LOOPNZ}
Decrementa ECX (FLAGS não modificado), se ECX $\neq$ 0
                      e ZF = 0, salta
\end{description}

As últimas duas instruções de loop são úteis para loops de busca sequencial. O
seguinte pseudo-código:
\begin{lstlisting}[stepnumber=0]{}
sum = 0;
for( i=10; i >0; i-- )
  sum += i;
\end{lstlisting}
\noindent pode ser traduzido em assembly como:
\begin{AsmCodeListing}[frame=none]
      mov    eax, 0          ; eax is sum
      mov    ecx, 10         ; ecx is i
loop_start:
      add    eax, ecx
      loop   loop_start
\end{AsmCodeListing}

\section{Traduzindo Estruturas de Controle Padrão}

Esta seção mostra como as estruturas de controle de linguagens de alto nível
podem ser implementadas na linguagem assembly.

\subsection{If statements \index{if statment|(}}
O seguinte pseudo-código:
\begin{lstlisting}[stepnumber=0]{}
if ( condition )
  then_block;
else
  else_block;
\end{lstlisting}
\noindent pode ser implementado como:
\begin{AsmCodeListing}[frame=none]
      ; code to set FLAGS
      jxx    else_block    ; seleciona xx tal que salta se a condição for falsa
      ; código para bloco then
      jmp    endif
else_block:
      ; código para bloco else
endif:
\end{AsmCodeListing}

Se não há nenhum else, então o salto do {\code else\_block} pode ser substituído por
um salto para {\code endif}.
\begin{AsmCodeListing}[frame=none]
      ; código para definir FLAGS
      jxx    endif          ; seleciona xx tal que salta se a condição for falsa
      ; código para bloco then
endif:
\end{AsmCodeListing}
\index{if statment|)}

\subsection{Ciclos While \index{while loop|(}}
O ciclo \emph{while} é testado no início do ciclo:
\begin{lstlisting}[stepnumber=0]{}
while( condição ) {
  corpo do ciclo;
}
\end{lstlisting}
\noindent Isto poderia ser traduzido em:
\begin{AsmCodeListing}[frame=none]
while:
      ; código para definir FLAGS baseado em condição
      jxx    endwhile       ; seleciona xx tal que salta se falso
      ; corpo do ciclo
      jmp    while
endwhile:
\end{AsmCodeListing}
\index{while loop|)}

\subsection{Ciclos do-while \index{do while loop|(}}
O ciclo \emph{do while} é testado ao final:
\begin{lstlisting}[stepnumber=0]{}
do {
  corpo do ciclo;
} while( condição );
\end{lstlisting}
\noindent Isto poderia ser traduzido em:
\begin{AsmCodeListing}[frame=none]
do:
      ; corpo do ciclo
      ; código para definir FLAGS baseado em condição
      jxx    do          ; seleciona xx tal que salta se verdadeiro
      \end{AsmCodeListing}
\index{do while loop|)}


\begin{figure}[t]
\begin{lstlisting}[frame=tlrb]{}
  unsigned guess;   /* conjectura atual para primo   */
  unsigned factor;  /* possível fator da conjectura     */
  unsigned limit;   /* encontrar primos até este valor */

  printf("Encontre primos até: ");
  scanf("%u", &limit);
  printf("2\n");    /* trate dois primeiros primos como  */
  printf("3\n");    /* caso especial               */
  guess = 5;        /* conjectura inicial */
  while ( guess <= limit ) {
    /* procure um fator da conjectura */
    factor = 3;
    while ( factor*factor < guess &&
            guess % factor != 0 )
     factor += 2;
    if ( guess % factor != 0 )
      printf("%d\n", guess);
    guess += 2;    /* apenas procure por números ímpares */
  }
\end{lstlisting}
\caption{}\label{fig:primec}
\end{figure}

\section{Exemplo: Encontrando Números Primos}
Esta seção mostra um programa que encontra números primos. Lembrando que
números primos são divisíveis apenas por 1 e ele próprio. Não existe uma
fórmula para fazer isso. O método basico utilizado por este programa é
encontrar os fatores de todos números ímpares\footnote{2 é o único número par
primo.} abaixo de um dado limite. Se não há fator a ser encontrado para um número
ímpar, então ele é primo.  Figure~\ref{fig:primec} mostra o algoritmo
base escrito em C.

Aqui a versão em assembly:
\index{prime.asm|(}
\begin{AsmCodeListing}[label=prime.asm]
%include "asm_io.inc"
segment .data
Message         db      "Encontre primos até: ", 0

segment .bss
Limit           resd    1               ; encontre primos até este limite
Guess           resd    1               ; a conjectura atual para o primo

segment .text
        global  _asm_main
_asm_main:
        enter   0,0               ; rotina inicial
        pusha

        mov     eax, Message
        call    print_string
        call    read_int             ; scanf("%u", & limit );
        mov     [Limit], eax

        mov     eax, 2               ; printf("2\n");
        call    print_int
        call    print_nl
        mov     eax, 3               ; printf("3\n");
        call    print_int
        call    print_nl

        mov     dword [Guess], 5     ; Guess = 5;
while_limit:                         ; while ( Guess <= Limit )
        mov     eax,[Guess]
        cmp     eax, [Limit]
        jnbe    end_while_limit      ; use jnbe já que os números são sem sinal

        mov     ebx, 3               ; ebx is factor = 3;
while_factor:
        mov     eax,ebx
        mul     eax                  ; edx:eax = eax*eax
        jo      end_while_factor     ; se a resposta não cabe em eax
        cmp     eax, [Guess]
        jnb     end_while_factor     ; if !(factor*factor < guess)
        mov     eax,[Guess]
        mov     edx,0
        div     ebx                  ; edx = edx:eax % ebx
        cmp     edx, 0
        je      end_while_factor     ; if !(guess % factor != 0)

        add     ebx,2                ; factor += 2;
        jmp     while_factor
end_while_factor:
        je      end_if               ; if !(guess % factor != 0)
        mov     eax,[Guess]          ; printf("%u\n")
        call    print_int
        call    print_nl
end_if:
        add     dword [Guess], 2     ; guess += 2
        jmp     while_limit
end_while_limit:

        popa
        mov     eax, 0            ; retorne C
        leave                     
        ret
\end{AsmCodeListing}
\index{prime.asm|)}
