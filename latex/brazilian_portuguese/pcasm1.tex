% -*-latex-*-
\chapter{Introdução}
\section{Sistemas de Numeração}

A memória em um computador consiste em números. A memória de um computador não 
armazena esses números em decimal (base 10). Por quê se simplifica bastante o 
hardware, computadores armazenam toda a informação no formato binário (base 2). 
Primeiramente, vamos revisar o sistema decimal.

\subsection{Decimal\index{decimal}}

Números em base 10 são compostos de 10 possíveis digitos (0-9). Cada dígito de 
um número é associado a uma potência de 10 de acordo com sua posição no número.
Por exemplo:
\begin{displaymath}
234 = 2 \times 10^2 + 3 \times 10^1 + 4 \times 10^0
\end{displaymath}

\subsection{Binário\index{binary|(}}

Números em base 2 são compostos de 2 possíveis dígitos (0 e 1). Cada dígito de 
um número é associado a uma potência de 2 de acordo com sua posição no número. 
(Um único dígito binário é dito um bit.) Por exemplo\footnote{O 2 subsescrito 
é usado para mostrar que um número está representado em binário e não decimal}:
\begin{eqnarray*}
11001_2 & = & 1 \times 2^4 + 1 \times 2^3 + 0 \times 2^2 + 0 \times 2^1 
              + 1 \times 2^0 \\
 & = & 16 + 8 + 1 \\
 & = & 25 
\end{eqnarray*}

Isso mostra como números binários podem ser convertidos para decimal. A 
Tabela~\ref{tab:dec-bin} mostra como são representados os primeiros números em 
\begin{table}[t]
\begin{center}
\begin{tabular}{||c|c||cc||c|c||}
\hline
Decimal & Binário & & & Decimal & Binário \\
\hline
0       & 0000   & & & 8       & 1000 \\
\hline
1       & 0001   & & & 9       & 1001 \\
\hline
2       & 0010   & & & 10      & 1010 \\
\hline
3       & 0011   & & & 11      & 1011 \\
\hline
4       & 0100   & & & 12      & 1100 \\
\hline
5       & 0101   & & & 13      & 1101 \\
\hline
6       & 0110   & & & 14      & 1110 \\
\hline
7       & 0111   & & & 15      & 1111 \\
\hline
\end{tabular}
\caption{Decimal de 0 a 15 em Binário\label{tab:dec-bin}}
\end{center}
\end{table}


\begin{figure}[h]
\begin{center}
\begin{tabular}{|rrrrrrrrp{.1cm}|p{.1cm}rrrrrrrr|}
\hline
& \multicolumn{7}{c}{Sem carry anterior} & & & \multicolumn{7}{c}{Com carry anterior} & \\
\hline
&  0 & &  0 & &  1 & &  1 & & &  0 & &  0 & &  1 & & 1  & \\
& +0 & & +1 & & +0 & & +1 & & & +0 & & +1 & & +0 & & +1 &  \\
\cline{2-2} \cline{4-4} \cline{6-6} \cline{8-8} \cline{11-11} \cline{13-13} \cline{15-15} \cline{17-17}
& 0  & & 1  & & 1  & & 0  & & & 1  & & 0  & & 0  & & 1 & \\
&    & &    & &    & & c  & & &    & & c  & & c  & & c & \\
\hline
\end{tabular}

\caption{Soma binária (c representa \emph{carry})\label{fig:bin-add}}
%TODO: Change this so that it is clear that single bits are being added,
%not 4-bit numbers. Ideas: Table or do sums horizontally.
\index{binary!addition}
\end{center}
\end{figure}

A Figura~\ref{fig:bin-add} mostra como dígitos binários individuais (isto é, 
bits) podem ser somados. Segue um exemplo:

\begin{tabular}{r}
 $11011_2$ \\
+$10001_2$ \\
\hline
$101100_2$ \\
\end{tabular}

Se considerarmos a seguinte divisão em decimal:
\[ 1234 \div 10 = 123\; r\; 4 \]
podemos assumir que essa divisão remove o dígito decimal mais à direita do 
número e desloca os demais dígitos decimais em uma posição para a direita. 
Dividindo por dois fazemos uma operação similar, mas com os dígitos binários do 
número. Considere a seguinte divisão binária:
\[ 1101_2 \div 10_2 = 110_2\; r\; 1 \]
Esse fato pode ser usado para converter-se um número decimal em sua 
representação binária equivalente como mostra a Figura~\ref{fig:dec-convert}. 
Esse método encontra o dígito mais à direita primeiro, esse dígito é chamado de 
\emph{dígito menos significativo} (lsb). O dígito mais à esquerda é chamado de 
\emph{dígito mais significativo} (msb). A unidade básica de memória consiste em 
8 bits e é chamada de \emph{byte}.
\index{binary|)}

\begin{figure}[t]
\centering
\fbox{\parbox{\textwidth}{
\begin{eqnarray*}
\mathrm{Decimal} & \mathrm{Binary} \\
25 \div 2 = 12\;r\;1 & 11001 \div 10 = 1100\;r\;1 \\
12 \div 2 = 6\;r\;0  & 1100 \div 10 = 110\;r\;0 \\
6 \div 2 = 3\;r\;0   & 110 \div 10 = 11\;r\;0 \\
3 \div 2 = 1\;r\;1   & 11 \div 10 = 1\;r\;1 \\
1 \div 2 = 0\;r\;1   & 1 \div 10 = 0\;r\;1 \\
\end{eqnarray*}

\centering
Logo $25_{10} = 11001_{2}$
}}
\caption{Conversão decimal \label{fig:dec-convert}}
\end{figure}

\subsection{Hexadecimal\index{hexadecimal|(}}

Número hexadecimais usam a base 16. Hexadecimal (ou \emph{hex} abraviado) 
podem ser usados como uma forma abreviada de números binários. Hex tem 16 
possíveis dígitos. Isso cria um problema, visto que não há simbolos para 
represental esses dígitos extras depois do 9. Por converção, letras são usadas 
para representar esses dígitos extras. Os 16 dígitos hex são 0-9 e então A, B, 
C, D, E e F. O dígito A é equivalente a 10 em decimal, B é 11, etc. Cada 
dígito de um número hex é associado a uma potência de 16. Exemplo:
\begin{eqnarray*}
\rm
2BD_{16} & = & 2 \times 16^2 + 11 \times 16^1 + 13 \times 16^0 \\
         & = & 512 + 176 + 13 \\
         & = & 701 \\
\end{eqnarray*}
Para converter-se de decimal para hex, é usada a mesma ideia que foi usada 
para a conversão binária, exceto que dividimos por 16. Veja a figura 
Figura~\ref{fig:hex-conv} para um exemplo.

\begin{figure}[t]
\centering
\fbox{\parbox{\textwidth}{
\begin{eqnarray*}
589 \div 16 & = & 36\;r\;13 \\
36 \div 16 & = & 2\;r\;4 \\
2 \div 16 & = & 0\;r\;2 \\
\end{eqnarray*}

\centering
Logo $589 = 24\mathrm{D}_{16}$
}}
\caption{\label{fig:hex-conv}}
\end{figure}

A razão pela qual hex é util é que há uma forma bastante simples de 
converter-se entre hex e binário. Números binários se tornam grandes e 
desejeitados rapidamente. Hex fornece uma maneira muito mais compacta de 
representar binário.

Para converter números hex para binário, basta converter cada dígito hex para 
um número binário de 4 bits. Por exemplo, $\mathrm{24D}_{16}$ é convertido 
para \mbox{$0010\;0100\; 1101_2$}. Note que zeros à esqueda dos 4 bits são 
importantes! Se o zero à esquerda para o dígito do meio de $\mathrm{24D}_{16}$ 
não for considerado o resultado encontrado será incorreto. A conversão de 
binário para hex é tão simples quanto. Pode ser aplicado o processo reverso. 
Converta cada seguimento de 4 bits do número binário para hex. Comece pela 
direita, e não pela esquerda do número binário. Isso garante que o processo 
use o segmento de 4 bits correto\footnote{Se não estiver claro por quê o ponto 
de partida faz diferença, tente converter o exemplo começando pela esquerda.}. 
Exemplo:\newline

\begin{tabular}{cccccc}
$110$ & $0000$ & $0101$ & $1010$ & $0111$ & $1110_2$ \\
  $6$ & $0$    &   $5$  &   A  &  $7$   &    $\mathrm{E}_{16}$ \\
\end{tabular}\newline

Um número de 4 bits é dito um \emph{nibble} \index{nibble}. Assim, cada dígito 
hex corresponde a um nibble. Dois nibbles compões um byte e logo um byte pode 
ser representado por um número hex de dois dígitos. O valor de um byte variade 
0 a 11111111 em binário, 0 a FF em hex e 0 a 255 em decimal.

\index{hexadecimal|)}

\section{Organização de um Computador}

\subsection{Memória\index{memory|(}}

A unidade básica de memória é um byte. \index{byte} \MarginNote{A memória é 
medida em unidades de kilobytes (~$2^{10} = 1,024$ bytes), megabytes 
(~$2^{20} = 1,048,576$ bytes) e gigabytes (~$2^{30} = 1,073,741,824$ bytes).}
Um computador com 32 megabytes de momória pode armazenar aproximadamente 32 
milhões de bytes de informação. Cada byte na memória é rotulado por um 
unico numero conhecido como seu endereço, como mostra a 
Figura~\ref{fig:memory}.

\begin{figure}[ht]
\begin{center}
\begin{tabular}{rcccccccc}
Address & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 \\
\cline{2-9}
Memory & \multicolumn{1}{|c}{2A}  & \multicolumn{1}{|c}{45}  
       & \multicolumn{1}{|c}{B8} & \multicolumn{1}{|c}{20} 
       & \multicolumn{1}{|c}{8F} & \multicolumn{1}{|c}{CD} 
       & \multicolumn{1}{|c}{12} & \multicolumn{1}{|c|}{2E} \\
\cline{2-9}
\end{tabular}
\caption{ Endereços de Memória \label{fig:memory} }
\end{center}
\end{figure}

\begin{table}
\begin{center}
\begin{tabular}{|l|l|}
\hline
word & 2 bytes \\ \hline
double word & 4 bytes \\ \hline
quad word & 8 bytes \\ \hline
paragraph & 16 bytes \\ \hline
\end{tabular}
\caption{ Unidade de Memória \label{tab:mem_units} }
\end{center}
\end{table}

Frequentemente a memória é usada em blocos maiores do que bytes individuais. 
Na arquitetura PC, namoes foram dados para essas seções de memória maiores, 
como a Table~\ref{tab:mem_units} mostra.

Todos os dados na memória são números. Caracteres são armazenados usando-se um 
\emph{código de caracteres} que mapeia numeros para caracteres. Um dos mais 
populares códigos de caracters é conhecido como \emph{ASCII} (American 
Standard Code for Information Interchange). Um novo código, mais completo, que 
está suplementando o ASCII é o Unicode. Uma diferença fundamental entre os 
dois códigos é que o ASCII usa um byte para codificar um caracter, enquanto 
que o Unicode usa multiplos bytes. Há diferças variações distintas de 
Unicode. Em compiladores x86 de C/C++, Unicode é representa no código 
usando-se o tipo {\code wchar\_t} e a codificação UTF-16, que usa 16 bits (ou 
uma \emph{word}) por caractere. Por exemplo, o ASCII mapeia o byte $41_{16}$ 
($65_{10}$) para o caracter maiúsculo \emph{A}; o UTF-16 mapeia tal caracter 
para a word $0041_{16}$. Como o ASCII usa um byte, ele é limitado a somente 
256 caracters distintos\footnote{Na realidade, o ASCII usa apenas os 7 bits 
inferiores e então tem apenas 128 differentes valores para uso.}. O Unicode 
extende os valores ASCII e permite que muito mais caracteres seja 
representados. Isso é importante para representar-se caracteres para todas as 
linguas do mundo.
\index{memory|)}

\subsection{O CPU\index{CPU|(}}

A Unidade Central de Processamento (CPU) é o dispositivo físico que executa 
instruções. As instruções que os CPUss executam são geralmente bastante 
simples. Instruções podem requerir que os dados sobre os quais elas atuam 
sejam armazenadas in locais de armazenamento especiais no próprio CPU, 
chamados de \emph{registradores}. \index{register} O CPU pode acessar dados 
nos registradores muito mais rapidamente do que dados na memória. No entanto, 
o número de registradores em um CPU é limitado, de forma que o programador tem 
de tomar o cuidado de manter apenas os dados em uso presente nos registradores.

As instruções que um tipo de CPU executa constituem a \emph{linguagem de 
máquina} do CPU. \index{machine language} Programas de máquina tem uma 
estrutura muito mais básica que linguagens de alto nível. Instruções da 
linguagem de máquina são codificados como números crus, e não em formatos de 
texto amigáveis. Um CPU precisa ser capaz de decodificar o propósito de uma 
instrução muito rapidamente o com eficiência. Linguagens de máquina são 
projetadas com esse objetivo em mente, e não para que sejam facilmente 
decifráveis por humanos. Programas escritos em outras linguagens tem de ser 
convertidos para a linguagem de máquina nativa do CPU para serem executados 
pelo computador. Um \emph{compilador} \index{compiler} é um programa que 
traduz programas escritos em uma linguagem de programação para a linguagem de 
máquina de uma arquitetura de computadores particular. No geral, todo tipo de 
CPU tem sua própria lignaugem de máquina especifica. Essa é uma razão do por 
quê programas escritos para um Mac não podem executados em um PC do tipo IBM.

Computadores usam um \emph{relógio} \index{clock} para sincronizar a execução 
das \MarginNote{\emph{GHz} significa gigahertz ou um bilhão de ciclos por 
segundo. Um CPU de 1.5 GHz tem 1.5 bilhões de pulsos de relógio por segundo.} 
instruções. O relógio pulsa a uma frequência fixa (conhecida como a 
\emph{velocidade do relógio}). Quando você compra um computador de 1.5 GHz, 
1.5 GHz é a frequência de relógio\footnote{Na realidade, pulsos de relógio são 
usados em diversos componentes distintos de um computador. Os outros 
componentes frequêntemente usam uma velocidade de relógio diferente da do 
CPU.}. O relógio não acompanha minutos ou segundos. Ele simplesmente pulsa a 
uma taxa constante. Os eletrônicos do CPU usam os pulsos para realizar suas 
operações corretamente, assim como o pulsos de um metrônomo ajudam um músico a 
tocar no ritmo correto. O número de pulsos (ou, como são geralmente chamados, 
\empg{ciclos}) que uma instrução requere depende da geração e do modelo do CPU.
O número de ciclos depende da instrução que a precede e de outros fatores 
também.


\subsection{A família 80x86 de CPUs\index{CPU!80x86}}

PCs do tipo IBM contêm um CPU da Familia 80x86 da Intel (ou um clone de um).
Os CPUs nessa família tem todos alguns recursos comúm, incluindo uma linguagem 
de máquina básica. No entanto, os membros mais recentes molhoram os recursos 
imensamente.

\begin{description}

\item[8088,8086:] Esses CPUs são idênticos do ponto de vista da programação. 
Eles foram os CPUs usados nos primeiros PCs. Eles provêm diversos registros de 
16 bits: AX, BX, CX, DX, SI, DI, BP, SP, CS, DS, SS, ES, IP, FLAGS. Eles 
supor apenas até um megabyte de memória e operam somento no \emph{modo real}. 
Nesse modo, um programa pode acessar qualquer endereço de memória, até a 
memória de outros programas! Isso torna a debugagem e a segurança muito 
difíceis! Além disso, a memória de um programa tem de ser dividida em 
\emph{segmentos}. Cada segmento não pode execeder 64K.

\item[80286:] Esse CPU for usado nos PCs da classe AT. Ele adiciona algumas 
novas instruções à linguagem de máquina básica dos 8088/86. No entanto, seu 
principal novo recurso é o \emph{modo protegido de 16 bits}. Nesse modo, 
ele pode acessor até 16 megabytes e proteger programas de acessar a memória de 
uns aos outros. No entanto, programas ainda são divididos em segmentos que 
não podem ser maiores que 64K.

\item[80386:] Esse CPU aprimorou imensamente o 80286. Primeiramente, ele 
extende muito dos registradores para armazenar 32 bits (EAX, EBX, ECX, EDX, 
ESI, EDI, EBP, ESP, EIP) e adiciona dois novos registradores de 16 bits, FS e 
GS. Ele também um novo \emph{modo protegido de 32 bits}. Nesse modo, ele pode 
acessar até 4 gigabytes. Programas são novamente dividos em setores, mas 
agora cada segmento pode também ter até 4 gigabytes de tamanho!

\item[80486/Pentium/Pentium Pro:] Esses membros da família 80x86 adicionam 
algúns poucos novos recursos. Eles principalemnte aceleram a execução das 
instruções.


\item[Pentium MMX:] Esse processador adiciona as instruções MMX (eXtenções de 
MultiMedia) ao Pentium. Essas instruções podem acelerar operações gráficas 
comúns.

\item[Pentum II:] Esse é o processador Pentium Pro com as instruções MMX 
adicionadas. (O Pentium III é essencialmente apenas um Pentium II mais rápido.)

\end{description}
\index{CPU|)}

\subsection{Registradores de 16 bit do 8086\index{register|(}}

O CPU 8086 original oferecia quatro registradores de 16 bits de propósito 
geral: AX, BX, CX e DX. Cada um desses registradores poderia ser decomposto em 
dois registradores de 8 bits. Por exemplo, o registrador AX poderia ser 
decomposto nos registradores AH e AL como mostra a Figura~\ref{fig:AX_reg}. O 
registrador AH contêm os 8 bits superiores (ou mais elevados) de AX  e AL 
contêm os 8 bits inferiores de AX. Frequêntemente AH e AL são usados como 
registradores idependentes de um byte; no entanto, é importante notar-se que 
eles são idependentes de AX. Modificar-se o valor de AX irá modificar AH e AL 
e {\em vice versa}\/. Os registradores de propósito geral são usados em muitos 
das movimentações de dados e instruções aritmeticas.


\begin{figure}
\begin{center}
\begin{tabular}{cc}
\multicolumn{2}{c}{AX} \\
\hline
\multicolumn{1}{||c|}{AH} & \multicolumn{1}{c||}{AL} \\
\hline
\end{tabular}
\caption{O registrador AX \label{fig:AX_reg} }
\end{center}
\end{figure}

Existem dois registradores de índice de 16 bits\index{register!index}: SI e DI. 
Eles são frequêntimente usados como ponteiros, mas podem ser usados para 
muitos dos mesmos proprósitos que os registradores gerais. No entanto, eles 
não podem ser decompostos em registradores de 8 bits.

Os registradores de 16 bits BP e SP são usados para apontar-se para dados no 
stack da linguagem de máquina e são chamados de Ponteiro da 
Base\index{register!base pointer} e Ponteiro do 
Stack\index{register!stack pointer}, respectivamente. Esses serão discutidos 
posteriormente.

Os registradores de 16 bits CS, DS, SS e ES são \emph{registradores de 
segmento}. \index{register!segment} Eles denotam qual parte da memória é usada 
para diferentes partes do programa. CS significa Segmento de Código, DS 
significa Segmento de Dados, SS significa Segmento do Stack e ES significa 
Segmento Extra. O ES é usado como um registrados de segmento temporário. Os 
detalhes sobre esse registradores se encontram nas Seções~\ref{real_mode} e 
\ref{16prot_mode}.

O registrador Ponteiro de Instrução (IP) \index{register!IP} é usado com o CS 
para acompanhar o endereço da próxima instrução a ser executada pelo CPU. 
Normalmente, conforme uma instrução é executada, o IP é incrementado para 
apontar para a próxima instrução na memória.

O registrador FLAGS \index{register!FLAGS} armazena informações importantes 
sobre os resultados de uma instrução prévia. Esses resultados são armazenados 
como bits individuais no registrador. Por exemplo, o bit Z é 1 se o resultado 
da instrução prévia foi zero ou 0 caso contrário. Nem todas as instruções 
modificam os bits em FLAGS, consulte a tabela no apêndice para ver como 
instruções individuais afetam o registrador FLAGS.

\subsection{Registradores de 32 bits do 80386\index{register!32-bit}}

O 80386 e processadores posteriores tem registradores extendidos. Por exemplo, 
o registrador de 16 bits AX é extendido para 32 bits. Para ser compatível 
com verções anteriores, AX ainda se refere ao registrador de 16 bits e EAX é 
usado para referir-se para o registrador extendido de 32 bits. O AX consiste 
nos 16 bits inferiores do EAX, assim como o AL consiste nos 8 bits inferiores 
d AX (e do EAX). Não há nunhuma forma de acessar os 16 bits superiores de EAX 
diretamente. Os outras registradores extendidos são EBX, ECX, EDX, ESI e EDI.

Muitos outros registrador são extendidos também. O BP se torna 
EBP\index{register!base pointer}; o SP se torna ESP\index{register!stack 
pointer}; o FLAGS se torna EFLAGS\index{register!EFLAGS} e IP se torna 
EIP\index{register!EIP}. No entanto, ao contrário dos registradores de 
índice e de propósito geral, no modo protegido de 32 bits (discutidos abaixo) 
somente as verções extendidas desses registradores são usadas.

Os registradores de segmento ainda são de 16 bits no 80386. Há também dois 
novos registradores de segmento: o FS e GS\index{register!segment}. Seus nomes 
não significam nada. Eles são registradores de segmento temporários (assim 
como o ES).

Uma das definições do termo \emph{word} \index{word} refere-se ao tamanho 
dos registradores de dados do CPU. Para a família 80x86, o termo é agora um 
pouco confuso. Na Tabela~\ref{teb:mem_units}, pode-se notar que \emph{word} é 
definido ccomo 2 bytes (ou 16 bits). Tal segnificado foi atribuido ao termo 
logo após o 8086 ser lançado. Quando o 80386 foi desenvolvido, foi decidido 
não modificar-se a definição de \emph{word}, mesmo que o tamanho dos registros 
tenhna mudado.

\index{register|)}

\subsection{Modo Real \label{real_mode} \index{real mode|(}}

No \MarginNote{De onde vem o infame limite do DOS de 640K? O BIOS requere uma 
parde dos 1M para seu código e para dispositivos de hardware como o monitor de 
vídeo.} modo real, a memória é limitada a apenas um megabyte ($2^{20}$ bytes).
Endereços válidos variam de 00000 a FFFFF (em hex).\@ % \@ means end of sentence
Esses enereços querem um número de 20 bits. Obviamente, um número de 20 bits 
não irá caber em nenhum dos registradres de 16 bits do 8086. A Intel resolveu 
esse problema usando dois valores de 16 bits para determinar um endereço. O 
primeiro valor de 16 bits é dito \emph{seletor}. Os valores de um seletor 
devem ser armazenados em registros de segmentos. O segundo segundo valor de 
16 bits é dito o \emph{offset}. O endereço físico ao qual se refere um par 
\emph{seletor:offset} de 32 bits é computado pela formula
\[ 16 * {\rm seletor} + {\rm offset} \]
Multiplicar-se por 16 em hex é fácil, basta adicionar um 0 na extremidade 
direita do número. Por exemplo, o endereço físico ao qual se refere 
047C:0048 é dado por
\begin{center}
\begin{tabular}{r}
047C0 \\
+0048 \\
\hline
04808 \\
\end{tabular}
\end{center}
Com efeito, um valor seletor é um número de parágrafo
(veja a Tabela~\ref{tab:mem_units}).

Endereços realmente segmentados tem desvantagens:
\begin{itemize}
\item Um valor único de seletor pode referenciar 64K de momória apenas (o 
limite superior do offset de 16 bits). O quê acontece quanto um segmento tem 
mais do que 64K de código? Não podemos usar um único valor de CS para toda a 
execução do programa. O programa tem de ser dividido em seções (chamadas de 
\emph{segmentos}\index{momory!segments}) menores do que 64K em tamanho. Quando 
a execução passa de um segmento para o outro, o valor de CS tem de ser
alterado. Problemas similares ocorrem com grandes quantidades de dados e o
registrador DS. Isso pode ser bastante estranho!

\item Cada byte na memória não tem um único enderço segmentado. O endereço
físico 04808 pode ser referenciado por 047C:0048, 047D:0038, 047E:0028 ou
047B:0058.\@ Isso pode complicar a comparação de endereços segmentados.

\end{itemize}
\index{real mode|)}

\subsection{Modo Protegido de 16 bits \label{16prot_mode} \index{protected mode!16-bit|(}}

No modo protegido de 16 bits do 80286, valores de seletores são interpretados
de maneira completamente diferente do modo real. No modo real, um valor de
seletor é o número de parágrafo de memória física. No modo protegido, um valor
de seletor é um \emph{indíce} em uma \emph{tabela de descritores}. Em ambos os 
modos, programas são divididos em segmentos\index{momory:segments}. No modo
real, esses segmentos estão situados em posições fixas na memória física e o
valor de um seletor denota o número do parágrafo do inicio do segmento. No modo
protegido, os segmentos não estão em posições fixas na memória física. Na
realidade, eles não sequer tem de estar na memória!

O modo protegido usa uma tecnica chamada \emph{memória
virtual}\index{memory!virtual}. A ideia central da memória virtual é manter
apenas os dados e o código na memória que os programas estão usando no momento.
Outros dados e códigos são armazenados temporariamente no disco até que eles
sejam necessarios novamente. No modo protegido de 16 bits, segmentos são
movidos entre a memória e o disco conforme necessario. Quando um segmento é
devolvido do disco para a memória, é bastante provável que ele seja colocado em
uma área diferente da mómoria do que a que ele estava antes de ser transfirido
para o disco. Tudo isso é feito de forma transparente pelo sistema operacional.
O programa não precisa ser escrito de forma diferente para que a memória
virtual funcione.

No modo protegido, cada segmento é associado a uma entrada em uma tabela de
descritores. Essa tabela armazena toda a informação que o sistema precisa saber
sobre o segmento. Essa informação inclui: ele está ou não na memória; se está
memória, onde está; permições de acesso ({\em ex.\/}, somente-leitura). O
índice da entrada do segmento é o valor de seletor que é armazenado no
registrados de segmento.

Uma \MarginNote{Um renomado colunista de PCs chamou o CPU 286 de ``retardado''}
grande desvantagem do modo protegido de 16 bits é o fato de que offsets ainda
são quantidades de 16 bits. Consequentemente, o tamanho dos segmentos ainda é
limitado a no máximo 64K. Isso torna o uso de grandes arrays problemático!
\index{protected mode!16-bit|)}

\subsection{Modo Protegido de 32 bits\index{protected mode!32-bit|(}}

O 80386 introduziu o modo protegido de 32 bits. Há duas grandes diferenças
entre os modos protegidos de 32 e 16 bits do 386 e do 286, respectivamente:
\begin{enumerate}
\item

Offsets são extendidos para ter 32 bits. Isso permite a um offset alcançar
valores de até 4 bilhões. Assim, os segmentos podem ter tamanhos de até 4
gigabytes.

\item

Segmentos\index{memory!segments} podem ser divididos em unidades de 4K ditas
\emph{páginas}\index{memory!pages}. Os sistemas de memória 
virtual\index{memory!virtual} agora utilizam páginas ao invés de segmentos.
Isso significa que apenas parte de um segmento pode estar na memória em um dado
momento. No modo que 16 bits do 286, ou todo o segmento está na memória ou
nenhuma parte dele está. Isso não é prático para os segmentos de maior tamanho
que o modo de 32 bits introduziu.

\end{enumerate}

\index{protected mode!32-bit|)}

No Windows 3.x, \emph{modo padrão} fazia referência ao modo protegido de 16
bits do 286 e \emph{modo avançado} fazia referência ao modo que 32 bits.
Windows 9X, Windows NT/2000/XP, OS/2 e Linux todos rodam no modo protegido de
32 bits paginado.

\subsection{Interrupções\index{interrupt}}

Por vezes o fluxo natural de um programa tem de ser interrompido para que sejam
processados eventos que requerem um resposta rápido. O hardware de um
computador fornece um macanismo chamado \emph{interrupções} para tratar esses
eventos. Por exemplo, quando o mouse é movido, o hardware do mouse interrompe o
programa corrente para tratar o movimento do mouse (para mover o cursor do
mouse, \{\em etc.\/}) Interrupções fazem com que o controle de execução seja
transferido para um \emph{tratador de interrupção}. Tratadores de
Interrupção são rotinas que processam a interrupção. Cada tipo de interrupção é
associado a um número inteiro. No começo da memória física reside um tabela de
\emph{vetores de interrupção} que contêm os endereços segmentados dos 
tratadores de interrupção. O número de uma interrupção é assencialmente um
índice nessa tabela.

Interrupções externas são disparadas de fora do CPU. (O mouse é um exemplo
desse tipo.) Muitos dispositivos de I/O disparam interrupções ({\em e.g.\/},
teclado, cronômetro, drives de disco, CD-ROM e placas de audio). Interrupções
internas são disparadas de dentro do CPU, ou por um erro ou por uma instrução
de interrupção. Interrupções de erro são também chamadas de \emph{traps}.
Interrupções geradas por instruções de interrupção são chamadas de
\emph{interrupções de software}. O DOS usa esse tipo de interrupção para
implementar seu API (Interfácie de Programação de Aplicação). Sistemas
operacionais mais modernos (como Windows ou UNIX) usam uma interfácie baseada
em C. \footnote{No entanto, eles podem usar um interfácie de mais baixo nível
no nível do kernel}.

Muitos tratadores de interrupção retornam o controle de execução de volta
para o programa interrompido quando terminados. Eles restauram todos os
registradores para os valores armazenadas antes da ocorrência da interrupção.
Portanto, o programa interrompido roda como se nada houvesse acontecido (exceto
que ele perde alguns ciclos de CPU). Traps geralmente não retornam.
Frequentementa eles abortam o programa.

\section{Linguagem de Assembly}

\subsection{Linguagem de máquina\index{machine language}}

Todo tipo de CPU entende sua própria linguagem de máquina. Intruções na
linguagem de máquina são números armazenadas como bytes na memória. Cada
instrução tem seu próprio código númerico único chamado de \emph{código de
operação} ou \emph{opcode} \index{opcode}. As instruções dos processadores
80x86 variam em tamanho. O opcode está sempre situado no início da intrução.
Muitas instruções também incluem dados ({\em e.g.\/}, constantes ou endereços)
usados pela instrução.

É muito difícel programar-se em linguagem de máquina diretamente. Decifrar o
significado de instruções numéricamente codificadas é tedioso para seres
humanos. Por exemplo, a instruções que diz para somar os registradores EAX e
EBX e armazenar o resultado em EAX é códifica com os seguintes códigos hex:
\begin{quote}
   03 C3
\end{quote}
Isso não é nada obvio. Felizmente, um programada chamada de \emph{assembler}
\index{assembler} pode fazer esse trabalho braçal para o programador.

\subsection{Linguagem de assembly\index{assembly language|(}}

Um programa em linguagem de assembly é armazenado como text (assim como
programas em linguagens de alto nível). Cada instrução em assembly representa
exatamente uma instrução de máquina. Por exemplo, a instrução de soma descrita
ascima  seria representada em linguagem de assembly como:
\begin{CodeQuote}
   add eax, ebx
\end{CodeQuote}
Aqui o significado da instrução é \emph{muito} mais claro que no código de
máquina. A palavra {\code add} é um \emph{mnemônico} \index{mnemonic} para a
instrução de soma. A forma geral de uma instrução em assembly é:
\begin{CodeQuote}
  {\em mnemônico operando(s)}
\end{CodeQuote}

Um \emph{assembler} \index{assembler} é um programa que lê um arquivo de texto
como instruções em assembly que converte o assembly em código de máquina.
\emph{Compiladores} \index{compiler} são programas que fazem converções
similares para linguagens de programação de alto nível. Um assembler é muito
mais simples que um compilador. \MarginNote{Ciêntistas da computação demoram
alguns anos para descobrir como escrever um compilador!} Toda afirmação em uma
linguagem de assembly representa diretamente uma única instrução de máquina.
Afirmações em linguagens de alto nível são \emph{muito} mais complexas que
podem requere mais de uma instrução de máquina.

Outra importante diferença entra assembly e linguagens de alto-nível é que como
cada tipo de CPU distinto tem sua própria linguagem de máquina, ele tem também
sua própria linguagem de assembly. Traduzir programs em assembly entre
diferentes arquiteturas é \emph{muito} mais díficil que traduzir languagens de
alto-nível.

Os exemplos desse livro usam o Netwide Assembler ou NASM \index{NASM}. Ele está
diponível gratuitamente na Internet (consulte o prefácio para o URL). Outros
assemblers comuns são o Microsoft's Assembler (MASM) \index{MASM} ou o
Borland's Assembler (TASM). \index{TASM} Existem algumas diferenças na sintaxe
do assembly entre o MASM/TASM e o NASM.

\subsection{Operandos das instruções}

Instruções do código de máquina variam no número de operandos; no entanto, no
geral, cada instrução tem um número fixo de operandos (entre 0 e 3). Operandos
podem ter os seguintes tipos:
\begin{description}
\item[registrador:]
Esses operandos fazem referência direta aos conteudos do registradores do CPU.
\item[memória:]
Esses fazem referência a dados na memória. O endereço dos dados pode ser uma
constante ou pode ser computado apartir dos valores dos registradores.
Os endereços são sempre offsets do começo de um segmento.
\item[imediatos:]
\index{immediate}
Esses são valores fixos que são listados na própria instrução. Eles são
armazenados na própria instrução (no segmento de código), não no segmento de
dados.
\item[implicitos:]
Esses operandos não são explicitamente colocados. Por exemplo, a instrução de
incrementação adiciona um a um registrador ou memória. O um é implícito.
\end{description}
\index{assembly language|)}

\subsection{Instruções básicas}

A instrução mais básica é a instrução {\code MOV} \index{MOV}. Ele move dados
de um local para outro (como o operador de atribuição em um linguagem de
alto-nível). Ela recebe dois operandos:
\begin{CodeQuote}
  mov {\em dest, src}
\end{CodeQuote}
Os dados expecificados por {\em scr} é copiado para {\em dest\/}. Uma restrição
é que os operandos não podem ser ambos endereços de memória. Isso evidencia
outra questão de linguagens de assembly. Frequentemente existem regras
arbitrárias sobre como diferentes instruções são usadas. Os operandos também
precisam ter o mesmo tamanho. O valor de AX não pode ser armazenado em BL.

Por exemplo (ponto-virugula indica um comentário\index{comment}):
\begin{AsmCodeListing}[frame=none, numbers=none]
      mov    eax, 3   ; armazena 3 no registrador EAX (3 é um imediato)
      mov    bx, ax   ; armazena do valor de AX no registrador BX
\end{AsmCodeListing}

A instrução {\code ADD} \index{ADD} é usada para somar inteiros.
      add    eax, 4   ; eax = eax + 4
      add    al, ah   ; al = al + ah 
\end{AsmCodeListing}

A instrução {\code SUB} \index{SUB} subtrai inteiros.
\begin{AsmCodeListing}[frame=none, numbers=none]
      sub    bx, 10   ; bx = bx - 10
      sub    ebx, edi ; ebx = ebx - edi
\end{AsmCodeListing}

As instruções {\code INC} \index{INC} e {\code DEC} \index{DEC} incrementam ou
decrementam valores por um. Como o um é um operando implícito, o códico de
máquina de {\code INC} e {\code DEC} é menor que o das instruções {\code ADD} e 
{\code SUB} equivalentes.
\begin{AsmCodeListing}[frame=none, numbers=none]
      inc    ecx      ; ecx++
      dec    dl       ; dl--
\end{AsmCodeListing}

\subsection{Diretivas\index{directive|(}}

Uma \emph{diretiva} é um artefato de um assembler e não do CPU. Elas são em
geral usadas para instruir o assembly a fazer algo ou informar algo ao 
assembler. Elas não são traduzidas para código de máquina. Usos comuns de
diretivas são:
\begin{list}{$\bullet$}{\setlength{\itemsep}{0pt}}
\item definir constantes
\item definir memória para o armazenamento de dados
\item agrupar a memória em segmentos
\item incluir código fonte condicionalmente
\item incluir outros arquivos
\end{list}

O código em NASM passa por um preprocessador assim como em C. Ele tem muitos
dos mesmos comandos de preprocessador de C. No entanto, as diretivas de
prepocessamento em NASM comesam com \% ao invez de \# como em C.

\subsubsection{A diretiva equ\index{directive!equ}}

A diretiva {\code equ} pode usada para definir um \emph{simbolo}. Simbulos são
contantes nomeadas que podem ser usadas no programa em assembly. O formato é:
\begin{quote}
  \code {\em simbulo} equ {\em valor}
\end{quote}
Os valores de simbulos \emph{não} podem ser redefinidos posteriormente.

\subsubsection{A diretiva \%define\index{directive!\%define}}

Essa diretiva é semelhante à diretiva {\code \#define} em C. Ela é comumente
usada para definir macros constantes assim como em C.
\begin{AsmCodeListing}[frame=none, numbers=none]
\%define TAMANHO 100
      mov    eax, TAMANHO
\end{AsmCodeListing}
O código acima define uma macro nomeada {\code TAMANHO} e mostra seu uso em uma
instrução {\code MOV}. Macros são mais flexíveis que simbolos de dois modos.
Macros podem ser redefinidas e podem ser mais do que simples valores
constantes.

\subsubsection{Diretivas de dados\index{directive!data|(}}

\begin{table}[t]
\centering
\begin{tabular}{||c|c||} \hline
{\bf Unidade} & {\bf Letra} \\
\hline
byte & B \\
word & W \\
double word & D \\
quad word & Q \\
ten bytes & T \\
\hline
\end{tabular}
\caption{Letras para Diretivas {\code RESX} e {\code DX}
         \label{tab:size-letters} }
\end{table}

Data directives are used in data segments to define room for
memory. There are two ways memory can be reserved. The first way only
defines room for data; the second way defines room and an initial
value. The first method uses one of the {\code RES{\em
X}}\index{directive!RES\emph{X}} directives. The {\em X} is replaced
with a letter that determines the size of the object (or objects) that
will be stored. Table~\ref{tab:size-letters} shows the possible
values.

The second method (that defines an initial value, too) uses one of the
{\code D{\em X}} directives\index{directive!D\emph{X}}. The {\em X}
letters are the same as those in the {\code RES{\em X}} directives.

It is very common to mark memory locations with
\emph{labels}. \index{label} Labels allow one to easily refer to
memory locations in code. Below are several examples:
\begin{AsmCodeListing}[frame=none, numbers=none]
L1    db     0        ; byte labeled L1 with initial value 0
L2    dw     1000     ; word labeled L2 with initial value 1000
L3    db     110101b  ; byte initialized to binary 110101 (53 in decimal)
L4    db     12h      ; byte initialized to hex 12 (18 in decimal)
L5    db     17o      ; byte initialized to octal 17 (15 in decimal)
L6    dd     1A92h    ; double word initialized to hex 1A92
L7    resb   1        ; 1 uninitialized byte
L8    db     "A"      ; byte initialized to ASCII code for A (65)
\end{AsmCodeListing}

Double quotes and single quotes are treated the same. Consecutive data
definitions are stored sequentially in memory. That is, the word L2 is
stored immediately after L1 in memory. Sequences of memory may also be
defined.
\begin{AsmCodeListing}[frame=none, numbers=none]
L9    db     0, 1, 2, 3              ; defines 4 bytes
L10   db     "w", "o", "r", 'd', 0   ; defines a C string = "word"
L11   db     'word', 0               ; same as L10
\end{AsmCodeListing}

The {\code DD}\index{directive!DD} directive can be used to define
both integer and single precision floating point\footnote{Single
precision floating point is equivalent to a {\code float} variable in
C.} constants. However, the {\code DQ}\index{directive!DQ} can only
be used to define double precision floating point constants.

For large sequences, NASM's {\code TIMES} \index{directive!TIMES}
directive is often useful. This directive repeats its operand a
specified number of times. For example,
\begin{AsmCodeListing}[frame=none, numbers=none]
L12   times 100 db 0                 ; equivalent to 100 (db 0)'s
L13   resw   100                     ; reserves room for 100 words
\end{AsmCodeListing}
\index{directive!data|)}
\index{directive|)}

\index{label|(}
Remember that labels  can be used to refer to data in code. There are
two ways that a label can be used. If a plain label is used, it is
interpreted as the address (or offset) of the data. If the label is
placed inside square brackets ({\code []}), it is interpreted as the data at
the address. In other words, one should think of a label as a \emph{pointer}
to the data and the square brackets dereferences the pointer just as
the asterisk does in C. (MASM/TASM follow a different convention.) 
In 32-bit mode, addresses are 32-bit. Here are some examples:
\begin{AsmCodeListing}[frame=none]
      mov    al, [L1]      ; copy byte at L1 into AL
      mov    eax, L1       ; EAX = address of byte at L1
      mov    [L1], ah      ; copy AH into byte at L1
      mov    eax, [L6]     ; copy double word at L6 into EAX
      add    eax, [L6]     ; EAX = EAX + double word at L6
      add    [L6], eax     ; double word at L6 += EAX
      mov    al, [L6]      ; copy first byte of double word at L6 into AL
\end{AsmCodeListing}
Line 7 of the examples shows an important property of NASM. The assembler does
\emph{not} keep track of the type of data that a label refers to. It is up
to the programmer to make sure that he (or she) uses a label correctly. Later
it will be common to store addresses of data in registers and use the register
like a pointer variable in C. Again, no checking is made that a pointer is
used correctly. In this way, assembly is much more error prone than even C.

Consider the following instruction:
\begin{AsmCodeListing}[frame=none, numbers=none]
      mov    [L6], 1             ; store a 1 at L6
\end{AsmCodeListing}
This statement produces an {\code operation size not specified} error. Why?
Because the assembler does not know whether to store the 1 as a byte, word
or double word. To fix this, add a size specifier:
\begin{AsmCodeListing}[frame=none, numbers=none]
      mov    dword [L6], 1       ; store a 1 at L6
\end{AsmCodeListing}
\index{DWORD}This tells the assembler to store an 1 at the double word that starts at
{\code L6}. Other size specifiers are: {\code BYTE}\index{BYTE}, {\code WORD}\index{WORD},
{\code QWORD}\index{QWORD} and {\code TWORD}\footnote{{\code TWORD} defines a ten byte
area of memory. The floating point coprocessor uses this data type.}\index{TWORD}.
\index{label|)}

\subsection{Input and Output \index{I/O|(}}

Input and output are very system dependent activities. It involves
interfacing with the system's hardware. High level languages, like C,
provide standard libraries of routines that provide a simple, uniform
programming interface for I/O.  Assembly languages provide no standard
libraries. They must either directly access hardware (which is a privileged
operation in protected mode) or use whatever low level routines that the
operating system provides.

\index{I/O!asm\_io library|(} 
It is very common for assembly routines to be interfaced with C. One
advantage of this is that the assembly code can use the standard C
library I/O routines.  However, one must know the rules for passing
information between routines that C uses. These rules are too
complicated to cover here. (They are covered later!) To simplify I/O,
the author has developed his own routines that hide the complex C
rules and provide a much more simple interface.  Table~\ref{tab:asmio}
describes the routines provided. All of the routines preserve the
value of all registers, except for the read routines. These routines
do modify the value of the EAX register. To use these routines, one
must include a file with information that the assembler needs to use
them.  To include a file in NASM, use the {\code \%include}
preprocessor directive. The following line includes the file needed by
the author's I/O routines\footnote{The {\code asm\_io.inc} (and the
{\code asm\_io} object file that {\code asm\_io.inc} requires) are in
the example code downloads on the web page for this tutorial, {\code
http://pacman128.github.io/pcasm/}}:
\begin{AsmCodeListing}[frame=none, numbers=none]
%include "asm_io.inc"
\end{AsmCodeListing}

\begin{table}[t]
\centering
\begin{tabular}{lp{3.5in}}
{\bf print\_int} & prints out to the screen the value of the integer stored 
                  in EAX \\
{\bf print\_char} & prints out to the screen the character whose
                    ASCII value stored in AL \\
{\bf print\_string} & prints out to the screen the contents of the string
                     at the {\em address} stored in EAX. The string must be
                     a C-type string ({\em i.e.} null terminated). \\
{\bf print\_nl} & prints out to the screen a new line character. \\
{\bf read\_int} & reads an integer from the keyboard and stores it into the
                 EAX register. \\
{\bf read\_char} & reads a single character from the keyboard and stores its
                  ASCII code into the EAX register. \\
\end{tabular}
\caption{Assembly I/O Routines \label{tab:asmio} \index{I/O!asm\_io library!print\_int}
\index{I/O!asm\_io library!print\_char} \index{I/O!asm\_io library!print\_string} 
\index{I/O!asm\_io library!print\_nl} \index{I/O!asm\_io library!read\_int}
\index{I/O!asm\_io library!read\_char}}
\end{table}

To use one of the print routines, one loads EAX with the correct value and
uses a {\code CALL} instruction to invoke it. The {\code CALL} instruction
is equivalent to a function call in a high level language. It jumps execution
to another section of code, but returns back to its origin after the routine
is over. The example program below shows several examples of calls to these
I/O routines.

\subsection{Debugging\index{debugging|(}}

The author's library also contains some useful routines for debugging 
programs. These debugging routines display information about the state of
the computer without modifying the state. These routines are really
\emph{macros} that preserve the current state of the CPU and then make a
subroutine call. The macros are defined in the {\code asm\_io.inc} file
discussed above. Macros are used like ordinary instructions. Operands of
macros are separated by commas.

There are four debugging routines named {\code dump\_regs}, {\code
dump\_mem}, {\code dump\_stack} and {\code dump\_math}; they display
the values of registers, memory, stack and the math coprocessor,
respectively.
\begin{description}

\item[dump\_regs]
\index{I/O!asm\_io library!dump\_regs} 
This macro prints out the values of the registers (in hexadecimal) of
the computer to {\code stdout} (\emph{i.e.} the screen). It also
displays the bits set in the FLAGS\footnote{Chapter~2 discusses this
register} register. For example, if the zero flag is 1, \emph{ZF} is
displayed. If it is 0, it is not displayed. It takes a single integer
argument that is printed out as well. This can be used to distinguish
the output of different {\code dump\_regs} commands.

\item[dump\_mem]
\index{I/O!asm\_io library!dump\_mem} 
This macro prints out the values of a region of memory (in
hexadecimal) and also as ASCII characters. It takes three comma delimited
arguments. The first is an integer that is used to label the
output (just as {\code dump\_regs} argument). The second argument is
the address to display. (This can be a label.) The last argument is
the number of 16-byte paragraphs to display after the address. The
memory displayed will start on the first paragraph boundary before the
requested address.

\item[dump\_stack]
\index{I/O!asm\_io library!dump\_stack} 
This macro prints out the values on the CPU stack. (The stack will be
covered in Chapter~4.) The stack is organized as double words and this
routine displays them this way. It takes three comma delimited
arguments. The first is an integer label (like {\code
dump\_regs}). The second is the number of double words to display
\emph{below} the address that the {\code EBP} register holds and the
third argument is the number of double words to display \emph{above}
the address in {\code EBP}.

\item[dump\_math]
\index{I/O!asm\_io library!dump\_math} 
This macro prints out the values of the registers of the math coprocessor.
It takes a single integer argument that is used to label the output just as
the argument of {\code dump\_regs} does.
\end{description}
\index{debugging|)}
\index{I/O!asm\_io library|)} 
\index{I/O|)}

\section{Creating a Program}

Today, it is unusual to create a stand alone program written
completely in assembly language. Assembly is usually used to key certain
critical routines. Why? It is \emph{much} easier to program in a higher level 
language than in assembly. Also, using assembly makes a program very hard to
port to other platforms. In fact, it is rare to use assembly at all.

So, why should anyone learn assembly at all?
\begin{enumerate}
\item Sometimes code written in assembly can be faster and smaller than
      compiler generated code.
\item Assembly allows access to direct hardware features of the system that
      might be difficult or impossible to use from a higher level language.
\item Learning to program in assembly helps one gain a deeper understanding of
      how computers work.
\item Learning to program in assembly helps one understand better how compilers
      and high level languages like C work.
\end{enumerate}
These last two points demonstrate that learning assembly can be useful even if
one never programs in it later. In fact, the author rarely programs in
assembly, but he uses the ideas he learned from it everyday.

\subsection{First program}

\begin{figure}[t]
\begin{lstlisting}[frame=tlrb]{}
int main()
{
  int ret_status;
  ret_status = asm_main();
  return ret_status;
}
\end{lstlisting}
\caption{{\code driver.c} code\label{fig:driverProg} \index{C driver}}
\end{figure}

The early programs in this text will all start from the simple C
driver program in Figure~\ref{fig:driverProg}. It simply calls
another function named {\code asm\_main}. This is really a routine
that will be written in assembly. There are several advantages in
using the C driver routine. First, this lets the C system set up the
program to run correctly in protected mode. All the segments and their
corresponding segment registers will be initialized by C. The assembly
code need not worry about any of this. Secondly, the C library will
also be available to be used by the assembly code. The author's I/O
routines take advantage of this. They use C's I/O functions ({\code
printf}, {\em etc.}).  The following shows a simple assembly program.

\begin{AsmCodeListing}[label=first.asm]
; file: first.asm
; First assembly program. This program asks for two integers as
; input and prints out their sum.
;
; To create executable using djgpp:
; nasm -f coff first.asm
; gcc -o first first.o driver.c asm_io.o

%include "asm_io.inc"
;
; initialized data is put in the .data segment
;
segment .data
;
; These labels refer to strings used for output
;
prompt1 db    "Enter a number: ", 0       ; don't forget null terminator
prompt2 db    "Enter another number: ", 0
outmsg1 db    "You entered ", 0
outmsg2 db    " and ", 0
outmsg3 db    ", the sum of these is ", 0

;
; uninitialized data is put in the .bss segment
;
segment .bss
;
; These labels refer to double words used to store the inputs
;
input1  resd 1
input2  resd 1

;
; code is put in the .text segment
;
segment .text
        global  _asm_main
_asm_main:
        enter   0,0               ; setup routine
        pusha

        mov     eax, prompt1      ; print out prompt
        call    print_string

        call    read_int          ; read integer
        mov     [input1], eax     ; store into input1

        mov     eax, prompt2      ; print out prompt
        call    print_string

        call    read_int          ; read integer
        mov     [input2], eax     ; store into input2

        mov     eax, [input1]     ; eax = dword at input1
        add     eax, [input2]     ; eax += dword at input2
        mov     ebx, eax          ; ebx = eax

        dump_regs 1                ; print out register values
        dump_mem  2, outmsg1, 1    ; print out memory
;
; next print out result message as series of steps
;
        mov     eax, outmsg1
        call    print_string      ; print out first message
        mov     eax, [input1]     
        call    print_int         ; print out input1
        mov     eax, outmsg2
        call    print_string      ; print out second message
        mov     eax, [input2]
        call    print_int         ; print out input2
        mov     eax, outmsg3
        call    print_string      ; print out third message
        mov     eax, ebx
        call    print_int         ; print out sum (ebx)
        call    print_nl          ; print new-line

        popa
        mov     eax, 0            ; return back to C
        leave                     
        ret
\end{AsmCodeListing}

Line~13 of the program defines a section of the program that specifies
memory to be stored in the data segment (whose name is {\code
.data})\index{data segment}. Only initialized data should be defined
in this segment. On lines~17 to 21, several strings are declared. They
will be printed with the C library and so must be terminated with a
\emph{null} character (ASCII code 0).  Remember there is a big
difference between {\code 0} and {\code '0'}.

Uninitialized data should be declared in the bss segment (named {\code
.bss} on line 26)\index{bss segment}. This segment gets its name from an early UNIX-based
assembler operator that meant ``block started by symbol.'' There is
also a stack segment too. It will be discussed later.

The code segment \index{code segment} is named {\code .text}
historically. It is where instructions are placed. Note that the code
label for the main routine (line~38) has an underscore prefix.  This
is part of the \emph{C calling convention}. \index{calling
convention!C} This convention specifies the rules C uses when compiling
code. It is very important to know this convention when interfacing C
and assembly. Later the entire convention will be presented; however,
for now, one only needs to know that all C symbols ({\em i.e.},
functions and global variables) have a underscore prefix appended to
them by the C compiler. (This rule is specifically for DOS/Windows,
the Linux C compiler does not prepend anything to C symbol names.)

The {\code global} {\index{directive!global} directive on line 37
tells the assembler to make the {\code \_asm\_main} label
global. Unlike in C, labels have \emph{internal scope} by
default. This means that only code in the same module can use the
label. The {\code global} directive gives the specified label (or
labels) \emph{external scope}. This type of label can be accessed by
any module in the program. The {\code asm\_io} module declares the
{\code print\_int}, {\em et.al.\/} labels to be global. This is why
one can use them in the {\code first.asm} module.

\subsection{Compiler dependencies}

The assembly code above is specific to the free GNU\footnote{GNU is a
project of the Free Software Foundation ({\code
http://www.fsf.org})}-based DJGPP \index{compiler!DJGPP} C/C++
compiler.\footnote{\code http://www.delorie.com/djgpp} This compiler
can be freely downloaded from the Internet. It requires a 386-based PC
or better and runs under DOS, Windows 95/98 or NT. This compiler uses
object files in the COFF (Common Object File Format) format. To
assemble to this format use the {\code -f~coff} switch with {\code
nasm} (as shown in the comments of the above code). The extension of
the resulting object file will be {\code o}.

The Linux C compiler is a GNU compiler also. \index{compiler!gcc} To
convert the code above to run under Linux, simply remove the
underscore prefixes in lines~37 and 38. Linux uses the ELF (Executable
and Linkable Format) format for object files. Use the {\code -f~elf}
switch for Linux. It also produces an object with an {\code o}
extension.\MarginNote{The compiler specific example files, available
from the author's web site, have already been modified to work with
the appropriate compiler.}

Borland C/C++ \index{compiler!Borland} is another popular compiler. It
uses the Microsoft OMF format for object files. Use the {\code -f~obj}
switch for Borland compilers. The extension of the object file will be
{\code obj}. The OMF format uses different {\code segment} directives
than the other object formats. The data segment (line~13) must be
changed to:
\begin{CodeQuote}
segment \_DATA public align=4 class=DATA use32
\end{CodeQuote}
The bss segment (line 26) must be changed to:
\begin{CodeQuote}
segment \_BSS public align=4 class=BSS use32
\end{CodeQuote}
The text segment (line 36) must be changed to:
\begin{CodeQuote}
segment \_TEXT public align=1 class=CODE use32
\end{CodeQuote}
In addition a new line should be added before line 36:
\begin{CodeQuote}
group DGROUP \_BSS \_DATA
\end{CodeQuote}

The Microsoft C/C++ \index{compiler!Microsoft} compiler can use either
the OMF format or the Win32 format for object files. (If given a OMF
format, it converts the information to Win32 format internally.) Win32
format allows segments to be defined just as for DJGPP and Linux. Use
the {\code -f~win32} switch to output in this mode. The extension of
the object file will be {\code obj}.

\subsection{Assembling the code}

The first step is to assemble the code. From the command line, type:
\begin{CodeQuote}
nasm -f {\em object-format} first.asm
\end{CodeQuote}
where {\em object-format} is either {\em coff\/}, {\em elf\/}, {\em obj} or
{\em win32} depending on what C compiler will be used. (Remember that the
source file must be changed for both Linux and Borland as well.)


\subsection{Compiling the C code}

Compile the {\code driver.c} file using a C compiler. For DJGPP, use:
\begin{CodeQuote}
gcc -c driver.c
\end{CodeQuote}
The {\code -c} switch means to just compile, do not attempt to link yet. This
same switch works on Linux, Borland and Microsoft compilers as well.

\subsection{Linking the object files \label{seq:linking} \index{linking|(}}

Linking is the process of combining the machine code and data in
object files and library files together to create an executable
file. As will be shown below, this process is complicated.

C code requires the standard C library and special \emph{startup code}
\index{startup code} to run.  It is \emph{much} easier to let the C
compiler call the linker with the correct parameters, than to try to
call the linker directly. For example, to link the code for the first
program using DJGPP, \index{compiler!DJGPP} use:
\begin{CodeQuote}
gcc -o first driver.o first.o asm\_io.o
\end{CodeQuote}
This creates an executable called {\code first.exe} (or just {\code first}
under Linux). 

With Borland, \index{compiler!Borland} one would use:
\begin{CodeQuote}
bcc32 first.obj driver.obj asm\_io.obj
\end{CodeQuote}
Borland uses the name of the first file listed to determine the executable
name. So in the above case, the program would be named {\code first.exe}.

It is possible to combine the compiling and linking step. For example,
\begin{CodeQuote}
gcc -o first {\em driver.c} first.o asm\_io.o
\end{CodeQuote}
Now {\code gcc} will compile {\code driver.c} and then link.
\index{linking|)}

\subsection{Understanding an assembly listing file \index{listing file|(}}

The {\code -l {\em listing-file}} switch can be used to tell {\code
nasm} to create a listing file of a given name. This file shows how
the code was assembled. Here is how lines~17 and 18 (in the data
segment) appear in the listing file. (The line numbers are in the
listing file; however notice that the line numbers in the source file
may not be the same as the line numbers in the listing file.)
\begin{Verbatim}[xleftmargin=\AsmMargin]
48 00000000 456E7465722061206E-     prompt1 db    "Enter a number: ", 0
49 00000009 756D6265723A2000
50 00000011 456E74657220616E6F-     prompt2 db    "Enter another number: ", 0
51 0000001A 74686572206E756D62-
52 00000023 65723A2000
 \end{Verbatim}
The first column in each line is the line number and the second is the
offset (in hex) of the data in the segment. The third column shows the
raw hex values that will be stored. In this case the hex data
correspond to ASCII codes. Finally, the text from the source file is
displayed on the line. The offsets listed in the second column are
very likely \emph{not} the true offsets that the data will be placed
at in the complete program.  Each module may define its own labels in
the data segment (and the other segments, too). In the link step (see
section~\ref{seq:linking}), all these data segment label definitions
are combined to form one data segment. The new final offsets are then
computed by the linker.

Here is a small section (lines~54 to 56 of the source file) of the
text segment in the listing file:
\begin{Verbatim}[xleftmargin=\AsmMargin]
94 0000002C A1[00000000]          mov     eax, [input1]
95 00000031 0305[04000000]        add     eax, [input2]
96 00000037 89C3                  mov     ebx, eax
\end{Verbatim}
The third column shows the machine code generated by the
assembly. Often the complete code for an instruction can not be
computed yet. For example, in line~94 the offset (or address) of
{\code input1} is not known until the code is linked. The assembler
can compute the op-code for the {\code mov} instruction (which from
the listing is A1), but it writes the offset in square brackets
because the exact value can not be computed yet. In this case, a
temporary offset of 0 is used because {\code input1} is at the
beginning of the part of the bss segment defined in this
file. Remember this does \emph{not} mean that it will be at the
beginning of the final bss segment of the program. When the code is linked,
the linker will insert the correct offset into the position. Other 
instructions, like line~96, do not reference any labels. Here the assembler
can compute the complete machine code.
\index{listing file|)}

\subsubsection{Big and Little Endian Representation \index{endianess|(}}
If one looks closely at line~95, something seems very strange about
the offset in the square brackets of the machine code. The {\code
input2} label is at offset 4 (as defined in this file); however, the
offset that appears in memory is not 00000004, but 04000000. Why? Different
processors store multibyte integers in different orders in
memory. There are two popular methods of storing integers: \emph{big
endian} and \emph{little endian}. \MarginNote{Endian is pronounced
like \emph{indian}.} Big endian is the method that seems the most
natural. The biggest (\emph{i.e.} most significant) byte is stored
first, then the next biggest, \emph{etc.} For example, the dword
00000004 would be stored as the four bytes 00~00~00~04.  IBM
mainframes, most RISC processors and Motorola processors all use this
big endian method. However, Intel-based processors use the little
endian method! Here the least significant byte is stored first. So,
00000004 is stored in memory as 04~00~00~00. This format is hardwired
into the CPU and can not be changed. Normally, the programmer does not
need to worry about which format is used. However, there are
circumstances where it is important.
\begin{enumerate}
\item When binary data is transfered between different computers (either from
      files or through a network).
\item When binary data is written out to memory as a multibyte integer and
      then read back as individual bytes or \emph{vice versa}.
\end{enumerate}

Endianness does not apply to the order of array elements. The first
element of an array is always at the lowest address. This applies to
strings (which are just character arrays). Endianness still
applies to the individual elements of the arrays. 
\index{endianess|)}

\begin{figure}[t]
\begin{AsmCodeListing}[label=skel.asm]
%include "asm_io.inc"
segment .data
;
; initialized data is put in the data segment here
;

segment .bss
;
; uninitialized data is put in the bss segment
;

segment .text
        global  _asm_main
_asm_main:
        enter   0,0               ; setup routine
        pusha

;
; code is put in the text segment. Do not modify the code before
; or after this comment.
;

        popa
        mov     eax, 0            ; return back to C
        leave                     
        ret
\end{AsmCodeListing}
\caption{Skeleton Program \label{fig:skel}}
\end{figure}

\section{Skeleton File \index{skeleton file}}

Figure~\ref{fig:skel} shows a skeleton file that can be used as a starting
point for writing assembly programs.







